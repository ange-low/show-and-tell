{"ast":null,"code":"/*!\n * Observer 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet gsap,\n  _coreInitted,\n  _clamp,\n  _win,\n  _doc,\n  _docEl,\n  _body,\n  _isTouch,\n  _pointerType,\n  ScrollTrigger,\n  _root,\n  _normalizer,\n  _eventTypes,\n  _context,\n  _getGSAP = () => gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap,\n  _startup = 1,\n  _observers = [],\n  _scrollers = [],\n  _proxies = [],\n  _getTime = Date.now,\n  _bridge = (name, value) => value,\n  _integrate = () => {\n    let core = ScrollTrigger.core,\n      data = core.bridge || {},\n      scrollers = core._scrollers,\n      proxies = core._proxies;\n    scrollers.push(..._scrollers);\n    proxies.push(..._proxies);\n    _scrollers = scrollers;\n    _proxies = proxies;\n    _bridge = (name, value) => data[name](value);\n  },\n  _getProxyProp = (element, property) => ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property],\n  _isViewport = el => !!~_root.indexOf(el),\n  _addListener = (element, type, func, passive, capture) => element.addEventListener(type, func, {\n    passive: passive !== false,\n    capture: !!capture\n  }),\n  _removeListener = (element, type, func, capture) => element.removeEventListener(type, func, !!capture),\n  _scrollLeft = \"scrollLeft\",\n  _scrollTop = \"scrollTop\",\n  _onScroll = () => _normalizer && _normalizer.isPressed || _scrollers.cache++,\n  _scrollCacheFunc = (f, doNotCache) => {\n    let cachingFunc = value => {\n      // since reading the scrollTop/scrollLeft/pageOffsetY/pageOffsetX can trigger a layout, this function allows us to cache the value so it only gets read fresh after a \"scroll\" event fires (or while we're refreshing because that can lengthen the page and alter the scroll position). when \"soft\" is true, that means don't actually set the scroll, but cache the new value instead (useful in ScrollSmoother)\n      if (value || value === 0) {\n        _startup && (_win.history.scrollRestoration = \"manual\"); // otherwise the new position will get overwritten by the browser onload.\n        let isNormalizing = _normalizer && _normalizer.isPressed;\n        value = cachingFunc.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0); //TODO: iOS Bug: if you allow it to go to 0, Safari can start to report super strange (wildly inaccurate) touch positions!\n        f(value);\n        cachingFunc.cacheID = _scrollers.cache;\n        isNormalizing && _bridge(\"ss\", value); // set scroll (notify ScrollTrigger so it can dispatch a \"scrollStart\" event if necessary\n      } else if (doNotCache || _scrollers.cache !== cachingFunc.cacheID || _bridge(\"ref\")) {\n        cachingFunc.cacheID = _scrollers.cache;\n        cachingFunc.v = f();\n      }\n      return cachingFunc.v + cachingFunc.offset;\n    };\n    cachingFunc.offset = 0;\n    return f && cachingFunc;\n  },\n  _horizontal = {\n    s: _scrollLeft,\n    p: \"left\",\n    p2: \"Left\",\n    os: \"right\",\n    os2: \"Right\",\n    d: \"width\",\n    d2: \"Width\",\n    a: \"x\",\n    sc: _scrollCacheFunc(function (value) {\n      return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;\n    })\n  },\n  _vertical = {\n    s: _scrollTop,\n    p: \"top\",\n    p2: \"Top\",\n    os: \"bottom\",\n    os2: \"Bottom\",\n    d: \"height\",\n    d2: \"Height\",\n    a: \"y\",\n    op: _horizontal,\n    sc: _scrollCacheFunc(function (value) {\n      return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;\n    })\n  },\n  _getTarget = (t, self) => (self && self._ctx && self._ctx.selector || gsap.utils.toArray)(t)[0] || (typeof t === \"string\" && gsap.config().nullTargetWarn !== false ? console.warn(\"Element not found:\", t) : null),\n  _getScrollFunc = (element, {\n    s,\n    sc\n  }) => {\n    // we store the scroller functions in an alternating sequenced Array like [element, verticalScrollFunc, horizontalScrollFunc, ...] so that we can minimize memory, maximize performance, and we also record the last position as a \".rec\" property in order to revert to that after refreshing to ensure things don't shift around.\n    _isViewport(element) && (element = _doc.scrollingElement || _docEl);\n    let i = _scrollers.indexOf(element),\n      offset = sc === _vertical.sc ? 1 : 2;\n    !~i && (i = _scrollers.push(element) - 1);\n    _scrollers[i + offset] || _addListener(element, \"scroll\", _onScroll); // clear the cache when a scroll occurs\n    let prev = _scrollers[i + offset],\n      func = prev || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc(function (value) {\n        return arguments.length ? element[s] = value : element[s];\n      })));\n    func.target = element;\n    prev || (func.smooth = gsap.getProperty(element, \"scrollBehavior\") === \"smooth\"); // only set it the first time (don't reset every time a scrollFunc is requested because perhaps it happens during a refresh() when it's disabled in ScrollTrigger.\n    return func;\n  },\n  _getVelocityProp = (value, minTimeRefresh, useDelta) => {\n    let v1 = value,\n      v2 = value,\n      t1 = _getTime(),\n      t2 = t1,\n      min = minTimeRefresh || 50,\n      dropToZeroTime = Math.max(500, min * 3),\n      update = (value, force) => {\n        let t = _getTime();\n        if (force || t - t1 > min) {\n          v2 = v1;\n          v1 = value;\n          t2 = t1;\n          t1 = t;\n        } else if (useDelta) {\n          v1 += value;\n        } else {\n          // not totally necessary, but makes it a bit more accurate by adjusting the v1 value according to the new slope. This way we're not just ignoring the incoming data. Removing for now because it doesn't seem to make much practical difference and it's probably not worth the kb.\n          v1 = v2 + (value - v2) / (t - t2) * (t1 - t2);\n        }\n      },\n      reset = () => {\n        v2 = v1 = useDelta ? 0 : v1;\n        t2 = t1 = 0;\n      },\n      getVelocity = latestValue => {\n        let tOld = t2,\n          vOld = v2,\n          t = _getTime();\n        (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);\n        return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1000;\n      };\n    return {\n      update,\n      reset,\n      getVelocity\n    };\n  },\n  _getEvent = (e, preventDefault) => {\n    preventDefault && !e._gsapAllow && e.preventDefault();\n    return e.changedTouches ? e.changedTouches[0] : e;\n  },\n  _getAbsoluteMax = a => {\n    let max = Math.max(...a),\n      min = Math.min(...a);\n    return Math.abs(max) >= Math.abs(min) ? max : min;\n  },\n  _setScrollTrigger = () => {\n    ScrollTrigger = gsap.core.globals().ScrollTrigger;\n    ScrollTrigger && ScrollTrigger.core && _integrate();\n  },\n  _initCore = core => {\n    gsap = core || _getGSAP();\n    if (!_coreInitted && gsap && typeof document !== \"undefined\" && document.body) {\n      _win = window;\n      _doc = document;\n      _docEl = _doc.documentElement;\n      _body = _doc.body;\n      _root = [_win, _doc, _docEl, _body];\n      _clamp = gsap.utils.clamp;\n      _context = gsap.core.context || function () {};\n      _pointerType = \"onpointerenter\" in _body ? \"pointer\" : \"mouse\";\n      // isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.\n      _isTouch = Observer.isTouch = _win.matchMedia && _win.matchMedia(\"(hover: none), (pointer: coarse)\").matches ? 1 : \"ontouchstart\" in _win || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;\n      _eventTypes = Observer.eventTypes = (\"ontouchstart\" in _docEl ? \"touchstart,touchmove,touchcancel,touchend\" : !(\"onpointerdown\" in _docEl) ? \"mousedown,mousemove,mouseup,mouseup\" : \"pointerdown,pointermove,pointercancel,pointerup\").split(\",\");\n      setTimeout(() => _startup = 0, 500);\n      _setScrollTrigger();\n      _coreInitted = 1;\n    }\n    return _coreInitted;\n  };\n_horizontal.op = _vertical;\n_scrollers.cache = 0;\nexport class Observer {\n  constructor(vars) {\n    this.init(vars);\n  }\n  init(vars) {\n    _coreInitted || _initCore(gsap) || console.warn(\"Please gsap.registerPlugin(Observer)\");\n    ScrollTrigger || _setScrollTrigger();\n    let {\n      tolerance,\n      dragMinimum,\n      type,\n      target,\n      lineHeight,\n      debounce,\n      preventDefault,\n      onStop,\n      onStopDelay,\n      ignore,\n      wheelSpeed,\n      event,\n      onDragStart,\n      onDragEnd,\n      onDrag,\n      onPress,\n      onRelease,\n      onRight,\n      onLeft,\n      onUp,\n      onDown,\n      onChangeX,\n      onChangeY,\n      onChange,\n      onToggleX,\n      onToggleY,\n      onHover,\n      onHoverEnd,\n      onMove,\n      ignoreCheck,\n      isNormalizer,\n      onGestureStart,\n      onGestureEnd,\n      onWheel,\n      onEnable,\n      onDisable,\n      onClick,\n      scrollSpeed,\n      capture,\n      allowClicks,\n      lockAxis,\n      onLockAxis\n    } = vars;\n    this.target = target = _getTarget(target) || _docEl;\n    this.vars = vars;\n    ignore && (ignore = gsap.utils.toArray(ignore));\n    tolerance = tolerance || 1e-9;\n    dragMinimum = dragMinimum || 0;\n    wheelSpeed = wheelSpeed || 1;\n    scrollSpeed = scrollSpeed || 1;\n    type = type || \"wheel,touch,pointer\";\n    debounce = debounce !== false;\n    lineHeight || (lineHeight = parseFloat(_win.getComputedStyle(_body).lineHeight) || 22); // note: browser may report \"normal\", so default to 22.\n    let id,\n      onStopDelayedCall,\n      dragged,\n      moved,\n      wheeled,\n      locked,\n      axis,\n      self = this,\n      prevDeltaX = 0,\n      prevDeltaY = 0,\n      passive = vars.passive || !preventDefault,\n      scrollFuncX = _getScrollFunc(target, _horizontal),\n      scrollFuncY = _getScrollFunc(target, _vertical),\n      scrollX = scrollFuncX(),\n      scrollY = scrollFuncY(),\n      limitToTouch = ~type.indexOf(\"touch\") && !~type.indexOf(\"pointer\") && _eventTypes[0] === \"pointerdown\",\n      // for devices that accommodate mouse events and touch events, we need to distinguish.\n      isViewport = _isViewport(target),\n      ownerDoc = target.ownerDocument || _doc,\n      deltaX = [0, 0, 0],\n      // wheel, scroll, pointer/touch\n      deltaY = [0, 0, 0],\n      onClickTime = 0,\n      clickCapture = () => onClickTime = _getTime(),\n      _ignoreCheck = (e, isPointerOrTouch) => (self.event = e) && ignore && ~ignore.indexOf(e.target) || isPointerOrTouch && limitToTouch && e.pointerType !== \"touch\" || ignoreCheck && ignoreCheck(e, isPointerOrTouch),\n      onStopFunc = () => {\n        self._vx.reset();\n        self._vy.reset();\n        onStopDelayedCall.pause();\n        onStop && onStop(self);\n      },\n      update = () => {\n        let dx = self.deltaX = _getAbsoluteMax(deltaX),\n          dy = self.deltaY = _getAbsoluteMax(deltaY),\n          changedX = Math.abs(dx) >= tolerance,\n          changedY = Math.abs(dy) >= tolerance;\n        onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY); // in ScrollTrigger.normalizeScroll(), we need to know if it was touch/pointer so we need access to the deltaX/deltaY Arrays before we clear them out.\n        if (changedX) {\n          onRight && self.deltaX > 0 && onRight(self);\n          onLeft && self.deltaX < 0 && onLeft(self);\n          onChangeX && onChangeX(self);\n          onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);\n          prevDeltaX = self.deltaX;\n          deltaX[0] = deltaX[1] = deltaX[2] = 0;\n        }\n        if (changedY) {\n          onDown && self.deltaY > 0 && onDown(self);\n          onUp && self.deltaY < 0 && onUp(self);\n          onChangeY && onChangeY(self);\n          onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);\n          prevDeltaY = self.deltaY;\n          deltaY[0] = deltaY[1] = deltaY[2] = 0;\n        }\n        if (moved || dragged) {\n          onMove && onMove(self);\n          if (dragged) {\n            onDrag(self);\n            dragged = false;\n          }\n          moved = false;\n        }\n        locked && !(locked = false) && onLockAxis && onLockAxis(self);\n        if (wheeled) {\n          onWheel(self);\n          wheeled = false;\n        }\n        id = 0;\n      },\n      onDelta = (x, y, index) => {\n        deltaX[index] += x;\n        deltaY[index] += y;\n        self._vx.update(x);\n        self._vy.update(y);\n        debounce ? id || (id = requestAnimationFrame(update)) : update();\n      },\n      onTouchOrPointerDelta = (x, y) => {\n        if (lockAxis && !axis) {\n          self.axis = axis = Math.abs(x) > Math.abs(y) ? \"x\" : \"y\";\n          locked = true;\n        }\n        if (axis !== \"y\") {\n          deltaX[2] += x;\n          self._vx.update(x, true); // update the velocity as frequently as possible instead of in the debounced function so that very quick touch-scrolls (flicks) feel natural. If it's the mouse/touch/pointer, force it so that we get snappy/accurate momentum scroll.\n        }\n        if (axis !== \"x\") {\n          deltaY[2] += y;\n          self._vy.update(y, true);\n        }\n        debounce ? id || (id = requestAnimationFrame(update)) : update();\n      },\n      _onDrag = e => {\n        if (_ignoreCheck(e, 1)) {\n          return;\n        }\n        e = _getEvent(e, preventDefault);\n        let x = e.clientX,\n          y = e.clientY,\n          dx = x - self.x,\n          dy = y - self.y,\n          isDragging = self.isDragging;\n        self.x = x;\n        self.y = y;\n        if (isDragging || Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum) {\n          onDrag && (dragged = true);\n          isDragging || (self.isDragging = true);\n          onTouchOrPointerDelta(dx, dy);\n          isDragging || onDragStart && onDragStart(self);\n        }\n      },\n      _onPress = self.onPress = e => {\n        if (_ignoreCheck(e, 1) || e && e.button) {\n          return;\n        }\n        self.axis = axis = null;\n        onStopDelayedCall.pause();\n        self.isPressed = true;\n        e = _getEvent(e); // note: may need to preventDefault(?) Won't side-scroll on iOS Safari if we do, though.\n        prevDeltaX = prevDeltaY = 0;\n        self.startX = self.x = e.clientX;\n        self.startY = self.y = e.clientY;\n        self._vx.reset(); // otherwise the t2 may be stale if the user touches and flicks super fast and releases in less than 2 requestAnimationFrame ticks, causing velocity to be 0.\n        self._vy.reset();\n        _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, passive, true);\n        self.deltaX = self.deltaY = 0;\n        onPress && onPress(self);\n      },\n      _onRelease = self.onRelease = e => {\n        if (_ignoreCheck(e, 1)) {\n          return;\n        }\n        _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);\n        let isTrackingDrag = !isNaN(self.y - self.startY),\n          wasDragging = self.isDragging,\n          isDragNotClick = wasDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3),\n          // some touch devices need some wiggle room in terms of sensing clicks - the finger may move a few pixels.\n          eventData = _getEvent(e);\n        if (!isDragNotClick && isTrackingDrag) {\n          self._vx.reset();\n          self._vy.reset();\n          //if (preventDefault && allowClicks && self.isPressed) { // check isPressed because in a rare edge case, the inputObserver in ScrollTrigger may stopPropagation() on the press/drag, so the onRelease may get fired without the onPress/onDrag ever getting called, thus it could trigger a click to occur on a link after scroll-dragging it.\n          if (preventDefault && allowClicks) {\n            gsap.delayedCall(0.08, () => {\n              // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular \"click\" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the \"real\"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the \"real\" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.\n              if (_getTime() - onClickTime > 300 && !e.defaultPrevented) {\n                if (e.target.click) {\n                  //some browsers (like mobile Safari) don't properly trigger the click event\n                  e.target.click();\n                } else if (ownerDoc.createEvent) {\n                  let syntheticEvent = ownerDoc.createEvent(\"MouseEvents\");\n                  syntheticEvent.initMouseEvent(\"click\", true, true, _win, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);\n                  e.target.dispatchEvent(syntheticEvent);\n                }\n              }\n            });\n          }\n        }\n        self.isDragging = self.isGesturing = self.isPressed = false;\n        onStop && wasDragging && !isNormalizer && onStopDelayedCall.restart(true);\n        onDragEnd && wasDragging && onDragEnd(self);\n        onRelease && onRelease(self, isDragNotClick);\n      },\n      _onGestureStart = e => e.touches && e.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e, self.isDragging),\n      _onGestureEnd = () => (self.isGesturing = false) || onGestureEnd(self),\n      onScroll = e => {\n        if (_ignoreCheck(e)) {\n          return;\n        }\n        let x = scrollFuncX(),\n          y = scrollFuncY();\n        onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);\n        scrollX = x;\n        scrollY = y;\n        onStop && onStopDelayedCall.restart(true);\n      },\n      _onWheel = e => {\n        if (_ignoreCheck(e)) {\n          return;\n        }\n        e = _getEvent(e, preventDefault);\n        onWheel && (wheeled = true);\n        let multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win.innerHeight : 1) * wheelSpeed;\n        onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);\n        onStop && !isNormalizer && onStopDelayedCall.restart(true);\n      },\n      _onMove = e => {\n        if (_ignoreCheck(e)) {\n          return;\n        }\n        let x = e.clientX,\n          y = e.clientY,\n          dx = x - self.x,\n          dy = y - self.y;\n        self.x = x;\n        self.y = y;\n        moved = true;\n        onStop && onStopDelayedCall.restart(true);\n        (dx || dy) && onTouchOrPointerDelta(dx, dy);\n      },\n      _onHover = e => {\n        self.event = e;\n        onHover(self);\n      },\n      _onHoverEnd = e => {\n        self.event = e;\n        onHoverEnd(self);\n      },\n      _onClick = e => _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self);\n    onStopDelayedCall = self._dc = gsap.delayedCall(onStopDelay || 0.25, onStopFunc).pause();\n    self.deltaX = self.deltaY = 0;\n    self._vx = _getVelocityProp(0, 50, true);\n    self._vy = _getVelocityProp(0, 50, true);\n    self.scrollX = scrollFuncX;\n    self.scrollY = scrollFuncY;\n    self.isDragging = self.isGesturing = self.isPressed = false;\n    _context(this);\n    self.enable = e => {\n      if (!self.isEnabled) {\n        _addListener(isViewport ? ownerDoc : target, \"scroll\", _onScroll);\n        type.indexOf(\"scroll\") >= 0 && _addListener(isViewport ? ownerDoc : target, \"scroll\", onScroll, passive, capture);\n        type.indexOf(\"wheel\") >= 0 && _addListener(target, \"wheel\", _onWheel, passive, capture);\n        if (type.indexOf(\"touch\") >= 0 && _isTouch || type.indexOf(\"pointer\") >= 0) {\n          _addListener(target, _eventTypes[0], _onPress, passive, capture);\n          _addListener(ownerDoc, _eventTypes[2], _onRelease);\n          _addListener(ownerDoc, _eventTypes[3], _onRelease);\n          allowClicks && _addListener(target, \"click\", clickCapture, true, true);\n          onClick && _addListener(target, \"click\", _onClick);\n          onGestureStart && _addListener(ownerDoc, \"gesturestart\", _onGestureStart);\n          onGestureEnd && _addListener(ownerDoc, \"gestureend\", _onGestureEnd);\n          onHover && _addListener(target, _pointerType + \"enter\", _onHover);\n          onHoverEnd && _addListener(target, _pointerType + \"leave\", _onHoverEnd);\n          onMove && _addListener(target, _pointerType + \"move\", _onMove);\n        }\n        self.isEnabled = true;\n        e && e.type && _onPress(e);\n        onEnable && onEnable(self);\n      }\n      return self;\n    };\n    self.disable = () => {\n      if (self.isEnabled) {\n        // only remove the _onScroll listener if there aren't any others that rely on the functionality.\n        _observers.filter(o => o !== self && _isViewport(o.target)).length || _removeListener(isViewport ? ownerDoc : target, \"scroll\", _onScroll);\n        if (self.isPressed) {\n          self._vx.reset();\n          self._vy.reset();\n          _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);\n        }\n        _removeListener(isViewport ? ownerDoc : target, \"scroll\", onScroll, capture);\n        _removeListener(target, \"wheel\", _onWheel, capture);\n        _removeListener(target, _eventTypes[0], _onPress, capture);\n        _removeListener(ownerDoc, _eventTypes[2], _onRelease);\n        _removeListener(ownerDoc, _eventTypes[3], _onRelease);\n        _removeListener(target, \"click\", clickCapture, true);\n        _removeListener(target, \"click\", _onClick);\n        _removeListener(ownerDoc, \"gesturestart\", _onGestureStart);\n        _removeListener(ownerDoc, \"gestureend\", _onGestureEnd);\n        _removeListener(target, _pointerType + \"enter\", _onHover);\n        _removeListener(target, _pointerType + \"leave\", _onHoverEnd);\n        _removeListener(target, _pointerType + \"move\", _onMove);\n        self.isEnabled = self.isPressed = self.isDragging = false;\n        onDisable && onDisable(self);\n      }\n    };\n    self.kill = self.revert = () => {\n      self.disable();\n      let i = _observers.indexOf(self);\n      i >= 0 && _observers.splice(i, 1);\n      _normalizer === self && (_normalizer = 0);\n    };\n    _observers.push(self);\n    isNormalizer && _isViewport(target) && (_normalizer = self);\n    self.enable(event);\n  }\n  get velocityX() {\n    return this._vx.getVelocity();\n  }\n  get velocityY() {\n    return this._vy.getVelocity();\n  }\n}\nObserver.version = \"3.12.5\";\nObserver.create = vars => new Observer(vars);\nObserver.register = _initCore;\nObserver.getAll = () => _observers.slice();\nObserver.getById = id => _observers.filter(o => o.vars.id === id)[0];\n_getGSAP() && gsap.registerPlugin(Observer);\nexport { Observer as default, _isViewport, _scrollers, _getScrollFunc, _getProxyProp, _proxies, _getVelocityProp, _vertical, _horizontal, _getTarget };","map":{"version":3,"names":["gsap","_coreInitted","_clamp","_win","_doc","_docEl","_body","_isTouch","_pointerType","ScrollTrigger","_root","_normalizer","_eventTypes","_context","_getGSAP","window","registerPlugin","_startup","_observers","_scrollers","_proxies","_getTime","Date","now","_bridge","name","value","_integrate","core","data","bridge","scrollers","proxies","push","_getProxyProp","element","property","indexOf","_isViewport","el","_addListener","type","func","passive","capture","addEventListener","_removeListener","removeEventListener","_scrollLeft","_scrollTop","_onScroll","isPressed","cache","_scrollCacheFunc","f","doNotCache","cachingFunc","history","scrollRestoration","isNormalizing","v","Math","round","iOS","cacheID","offset","_horizontal","s","p","p2","os","os2","d","d2","a","sc","arguments","length","scrollTo","_vertical","pageXOffset","op","pageYOffset","_getTarget","t","self","_ctx","selector","utils","toArray","config","nullTargetWarn","console","warn","_getScrollFunc","scrollingElement","i","prev","target","smooth","getProperty","_getVelocityProp","minTimeRefresh","useDelta","v1","v2","t1","t2","min","dropToZeroTime","max","update","force","reset","getVelocity","latestValue","tOld","vOld","_getEvent","e","preventDefault","_gsapAllow","changedTouches","_getAbsoluteMax","abs","_setScrollTrigger","globals","_initCore","document","body","documentElement","clamp","context","Observer","isTouch","matchMedia","matches","navigator","maxTouchPoints","msMaxTouchPoints","eventTypes","split","setTimeout","constructor","vars","init","tolerance","dragMinimum","lineHeight","debounce","onStop","onStopDelay","ignore","wheelSpeed","event","onDragStart","onDragEnd","onDrag","onPress","onRelease","onRight","onLeft","onUp","onDown","onChangeX","onChangeY","onChange","onToggleX","onToggleY","onHover","onHoverEnd","onMove","ignoreCheck","isNormalizer","onGestureStart","onGestureEnd","onWheel","onEnable","onDisable","onClick","scrollSpeed","allowClicks","lockAxis","onLockAxis","parseFloat","getComputedStyle","id","onStopDelayedCall","dragged","moved","wheeled","locked","axis","prevDeltaX","prevDeltaY","scrollFuncX","scrollFuncY","scrollX","scrollY","limitToTouch","isViewport","ownerDoc","ownerDocument","deltaX","deltaY","onClickTime","clickCapture","_ignoreCheck","isPointerOrTouch","pointerType","onStopFunc","_vx","_vy","pause","dx","dy","changedX","changedY","onDelta","x","y","index","requestAnimationFrame","onTouchOrPointerDelta","_onDrag","clientX","clientY","isDragging","startX","startY","_onPress","button","_onRelease","isTrackingDrag","isNaN","wasDragging","isDragNotClick","eventData","delayedCall","defaultPrevented","click","createEvent","syntheticEvent","initMouseEvent","screenX","screenY","dispatchEvent","isGesturing","restart","_onGestureStart","touches","_onGestureEnd","onScroll","_onWheel","multiplier","deltaMode","innerHeight","_onMove","_onHover","_onHoverEnd","_onClick","_dc","enable","isEnabled","disable","filter","o","kill","revert","splice","velocityX","velocityY","version","create","register","getAll","slice","getById","default"],"sources":["C:/Users/baros/Downloads/GSAP-Crack-master/src/Observer.js"],"sourcesContent":["/*!\n * Observer 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet gsap, _coreInitted, _clamp, _win, _doc, _docEl, _body, _isTouch, _pointerType, ScrollTrigger, _root, _normalizer, _eventTypes, _context,\n\t_getGSAP = () => gsap || (typeof(window) !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap),\n\t_startup = 1,\n\t_observers = [],\n\t_scrollers = [],\n\t_proxies = [],\n\t_getTime = Date.now,\n\t_bridge = (name, value) => value,\n\t_integrate = () => {\n\t\tlet core = ScrollTrigger.core,\n\t\t\tdata = core.bridge || {},\n\t\t\tscrollers = core._scrollers,\n\t\t\tproxies = core._proxies;\n\t\tscrollers.push(..._scrollers);\n\t\tproxies.push(..._proxies);\n\t\t_scrollers = scrollers;\n\t\t_proxies = proxies;\n\t\t_bridge = (name, value) => data[name](value);\n\t},\n\t_getProxyProp = (element, property) => ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property],\n\t_isViewport = el => !!~_root.indexOf(el),\n\t_addListener = (element, type, func, passive, capture) => element.addEventListener(type, func, {passive: passive !== false, capture: !!capture}),\n\t_removeListener = (element, type, func, capture) => element.removeEventListener(type, func, !!capture),\n\t_scrollLeft = \"scrollLeft\",\n\t_scrollTop = \"scrollTop\",\n\t_onScroll = () => (_normalizer && _normalizer.isPressed) || _scrollers.cache++,\n\t_scrollCacheFunc = (f, doNotCache) => {\n\t\tlet cachingFunc = value => { // since reading the scrollTop/scrollLeft/pageOffsetY/pageOffsetX can trigger a layout, this function allows us to cache the value so it only gets read fresh after a \"scroll\" event fires (or while we're refreshing because that can lengthen the page and alter the scroll position). when \"soft\" is true, that means don't actually set the scroll, but cache the new value instead (useful in ScrollSmoother)\n\t\t\tif (value || value === 0) {\n\t\t\t\t_startup && (_win.history.scrollRestoration = \"manual\"); // otherwise the new position will get overwritten by the browser onload.\n\t\t\t\tlet isNormalizing = _normalizer && _normalizer.isPressed;\n\t\t\t\tvalue = cachingFunc.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0); //TODO: iOS Bug: if you allow it to go to 0, Safari can start to report super strange (wildly inaccurate) touch positions!\n\t\t\t\tf(value);\n\t\t\t\tcachingFunc.cacheID = _scrollers.cache;\n\t\t\t\tisNormalizing && _bridge(\"ss\", value); // set scroll (notify ScrollTrigger so it can dispatch a \"scrollStart\" event if necessary\n\t\t\t} else if (doNotCache || _scrollers.cache !== cachingFunc.cacheID || _bridge(\"ref\")) {\n\t\t\t\tcachingFunc.cacheID = _scrollers.cache;\n\t\t\t\tcachingFunc.v = f();\n\t\t\t}\n\t\t\treturn cachingFunc.v + cachingFunc.offset;\n\t\t};\n\t\tcachingFunc.offset = 0;\n\t\treturn f && cachingFunc;\n\t},\n\t_horizontal = {s: _scrollLeft, p: \"left\", p2: \"Left\", os: \"right\", os2: \"Right\", d: \"width\", d2: \"Width\", a: \"x\", sc: _scrollCacheFunc(function(value) { return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0})},\n\t_vertical = {s: _scrollTop, p: \"top\", p2: \"Top\", os: \"bottom\", os2: \"Bottom\", d: \"height\", d2: \"Height\", a: \"y\", op: _horizontal, sc: _scrollCacheFunc(function(value) { return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0})},\n\t_getTarget = (t, self) => ((self && self._ctx && self._ctx.selector) || gsap.utils.toArray)(t)[0] || (typeof(t) === \"string\" && gsap.config().nullTargetWarn !== false ? console.warn(\"Element not found:\", t) : null),\n\n\t_getScrollFunc = (element, {s, sc}) => { // we store the scroller functions in an alternating sequenced Array like [element, verticalScrollFunc, horizontalScrollFunc, ...] so that we can minimize memory, maximize performance, and we also record the last position as a \".rec\" property in order to revert to that after refreshing to ensure things don't shift around.\n\t\t_isViewport(element) && (element = _doc.scrollingElement || _docEl);\n\t\tlet i = _scrollers.indexOf(element),\n\t\t\toffset = sc === _vertical.sc ? 1 : 2;\n\t\t!~i && (i = _scrollers.push(element) - 1);\n\t\t_scrollers[i + offset] || _addListener(element, \"scroll\", _onScroll); // clear the cache when a scroll occurs\n\t\tlet prev = _scrollers[i + offset],\n\t\t\tfunc = prev || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), true) || (_isViewport(element) ? sc : _scrollCacheFunc(function(value) { return arguments.length ? (element[s] = value) : element[s]; })));\n\t\tfunc.target = element;\n\t\tprev || (func.smooth = gsap.getProperty(element, \"scrollBehavior\") === \"smooth\"); // only set it the first time (don't reset every time a scrollFunc is requested because perhaps it happens during a refresh() when it's disabled in ScrollTrigger.\n\t\treturn func;\n\t},\n\t_getVelocityProp = (value, minTimeRefresh, useDelta) => {\n\t\tlet v1 = value,\n\t\t\tv2 = value,\n\t\t\tt1 = _getTime(),\n\t\t\tt2 = t1,\n\t\t\tmin = minTimeRefresh || 50,\n\t\t\tdropToZeroTime = Math.max(500, min * 3),\n\t\t\tupdate = (value, force) => {\n\t\t\t\tlet t = _getTime();\n\t\t\t\tif (force || t - t1 > min) {\n\t\t\t\t\tv2 = v1;\n\t\t\t\t\tv1 = value;\n\t\t\t\t\tt2 = t1;\n\t\t\t\t\tt1 = t;\n\t\t\t\t} else if (useDelta) {\n\t\t\t\t\tv1 += value;\n\t\t\t\t} else { // not totally necessary, but makes it a bit more accurate by adjusting the v1 value according to the new slope. This way we're not just ignoring the incoming data. Removing for now because it doesn't seem to make much practical difference and it's probably not worth the kb.\n\t\t\t\t\tv1 = v2 + (value - v2) / (t - t2) * (t1 - t2);\n\t\t\t\t}\n\t\t\t},\n\t\t\treset = () => { v2 = v1 = useDelta ? 0 : v1; t2 = t1 = 0; },\n\t\t\tgetVelocity = latestValue => {\n\t\t\t\tlet tOld = t2,\n\t\t\t\t\tvOld = v2,\n\t\t\t\t\tt = _getTime();\n\t\t\t\t(latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);\n\t\t\t\treturn (t1 === t2 || t - t2 > dropToZeroTime) ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1000;\n\t\t\t};\n\t\treturn {update, reset, getVelocity};\n\t},\n\t_getEvent = (e, preventDefault) => {\n\t\tpreventDefault && !e._gsapAllow && e.preventDefault();\n\t\treturn e.changedTouches ? e.changedTouches[0] : e;\n\t},\n\t_getAbsoluteMax = a => {\n\t\tlet max = Math.max(...a),\n\t\t\tmin = Math.min(...a);\n\t\treturn Math.abs(max) >= Math.abs(min) ? max : min;\n\t},\n\t_setScrollTrigger = () => {\n\t\tScrollTrigger = gsap.core.globals().ScrollTrigger;\n\t\tScrollTrigger && ScrollTrigger.core && _integrate();\n\t},\n\t_initCore = core => {\n\t\tgsap = core || _getGSAP();\n\t\tif (!_coreInitted && gsap && typeof(document) !== \"undefined\" && document.body) {\n\t\t\t_win = window;\n\t\t\t_doc = document;\n\t\t\t_docEl = _doc.documentElement;\n\t\t\t_body = _doc.body;\n\t\t\t_root = [_win, _doc, _docEl, _body];\n\t\t\t_clamp = gsap.utils.clamp;\n\t\t\t_context = gsap.core.context || function() {};\n\t\t\t_pointerType = \"onpointerenter\" in _body ? \"pointer\" : \"mouse\";\n\t\t\t// isTouch is 0 if no touch, 1 if ONLY touch, and 2 if it can accommodate touch but also other types like mouse/pointer.\n\t\t\t_isTouch = Observer.isTouch = _win.matchMedia && _win.matchMedia(\"(hover: none), (pointer: coarse)\").matches ? 1 : (\"ontouchstart\" in _win || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0) ? 2 : 0;\n\t\t\t_eventTypes = Observer.eventTypes = (\"ontouchstart\" in _docEl ? \"touchstart,touchmove,touchcancel,touchend\" : !(\"onpointerdown\" in _docEl) ? \"mousedown,mousemove,mouseup,mouseup\" : \"pointerdown,pointermove,pointercancel,pointerup\").split(\",\");\n\t\t\tsetTimeout(() => _startup = 0, 500);\n\t\t\t_setScrollTrigger();\n\t\t\t_coreInitted = 1;\n\t\t}\n\t\treturn _coreInitted;\n\t};\n\n_horizontal.op = _vertical;\n_scrollers.cache = 0;\n\nexport class Observer {\n\tconstructor(vars) {\n\t\tthis.init(vars);\n\t}\n\n\tinit(vars) {\n\t\t_coreInitted || _initCore(gsap) || console.warn(\"Please gsap.registerPlugin(Observer)\");\n\t\tScrollTrigger || _setScrollTrigger();\n\t\tlet {tolerance, dragMinimum, type, target, lineHeight, debounce, preventDefault, onStop, onStopDelay, ignore, wheelSpeed, event, onDragStart, onDragEnd, onDrag, onPress, onRelease, onRight, onLeft, onUp, onDown, onChangeX, onChangeY, onChange, onToggleX, onToggleY, onHover, onHoverEnd, onMove, ignoreCheck, isNormalizer, onGestureStart, onGestureEnd, onWheel, onEnable, onDisable, onClick, scrollSpeed, capture, allowClicks, lockAxis, onLockAxis} = vars;\n\t\tthis.target = target = _getTarget(target) || _docEl;\n\t\tthis.vars = vars;\n\t\tignore && (ignore = gsap.utils.toArray(ignore));\n\t\ttolerance = tolerance || 1e-9;\n\t\tdragMinimum = dragMinimum || 0;\n\t\twheelSpeed = wheelSpeed || 1;\n\t\tscrollSpeed = scrollSpeed || 1;\n\t\ttype = type || \"wheel,touch,pointer\";\n\t\tdebounce = debounce !== false;\n\t\tlineHeight || (lineHeight = parseFloat(_win.getComputedStyle(_body).lineHeight) || 22); // note: browser may report \"normal\", so default to 22.\n\t\tlet id, onStopDelayedCall, dragged, moved, wheeled, locked, axis,\n\t\t\tself = this,\n\t\t\tprevDeltaX = 0,\n\t\t\tprevDeltaY = 0,\n\t\t\tpassive = vars.passive || !preventDefault,\n\t\t\tscrollFuncX = _getScrollFunc(target, _horizontal),\n\t\t\tscrollFuncY = _getScrollFunc(target, _vertical),\n\t\t\tscrollX = scrollFuncX(),\n\t\t\tscrollY = scrollFuncY(),\n\t\t\tlimitToTouch = ~type.indexOf(\"touch\") && !~type.indexOf(\"pointer\") && _eventTypes[0] === \"pointerdown\", // for devices that accommodate mouse events and touch events, we need to distinguish.\n\t\t\tisViewport = _isViewport(target),\n\t\t\townerDoc = target.ownerDocument || _doc,\n\t\t\tdeltaX = [0, 0, 0], // wheel, scroll, pointer/touch\n\t\t\tdeltaY = [0, 0, 0],\n\t\t\tonClickTime = 0,\n\t\t\tclickCapture = () => onClickTime = _getTime(),\n\t\t\t_ignoreCheck = (e, isPointerOrTouch) => (self.event = e) && (ignore && ~ignore.indexOf(e.target)) || (isPointerOrTouch && limitToTouch && e.pointerType !== \"touch\") || (ignoreCheck && ignoreCheck(e, isPointerOrTouch)),\n\t\t\tonStopFunc = () => {\n\t\t\t\tself._vx.reset();\n\t\t\t\tself._vy.reset();\n\t\t\t\tonStopDelayedCall.pause();\n\t\t\t\tonStop && onStop(self);\n\t\t\t},\n\t\t\tupdate = () => {\n\t\t\t\tlet dx = self.deltaX = _getAbsoluteMax(deltaX),\n\t\t\t\t\tdy = self.deltaY = _getAbsoluteMax(deltaY),\n\t\t\t\t\tchangedX = Math.abs(dx) >= tolerance,\n\t\t\t\t\tchangedY = Math.abs(dy) >= tolerance;\n\t\t\t\tonChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY); // in ScrollTrigger.normalizeScroll(), we need to know if it was touch/pointer so we need access to the deltaX/deltaY Arrays before we clear them out.\n\t\t\t\tif (changedX) {\n\t\t\t\t\tonRight && self.deltaX > 0 && onRight(self);\n\t\t\t\t\tonLeft && self.deltaX < 0 && onLeft(self);\n\t\t\t\t\tonChangeX && onChangeX(self);\n\t\t\t\t\tonToggleX && ((self.deltaX < 0) !== (prevDeltaX < 0)) && onToggleX(self);\n\t\t\t\t\tprevDeltaX = self.deltaX;\n\t\t\t\t\tdeltaX[0] = deltaX[1] = deltaX[2] = 0\n\t\t\t\t}\n\t\t\t\tif (changedY) {\n\t\t\t\t\tonDown && self.deltaY > 0 && onDown(self);\n\t\t\t\t\tonUp && self.deltaY < 0 && onUp(self);\n\t\t\t\t\tonChangeY && onChangeY(self);\n\t\t\t\t\tonToggleY && ((self.deltaY < 0) !== (prevDeltaY < 0)) && onToggleY(self);\n\t\t\t\t\tprevDeltaY = self.deltaY;\n\t\t\t\t\tdeltaY[0] = deltaY[1] = deltaY[2] = 0\n\t\t\t\t}\n\t\t\t\tif (moved || dragged) {\n\t\t\t\t\tonMove && onMove(self);\n\t\t\t\t\tif (dragged) {\n\t\t\t\t\t\tonDrag(self);\n\t\t\t\t\t\tdragged = false;\n\t\t\t\t\t}\n\t\t\t\t\tmoved = false;\n\t\t\t\t}\n\t\t\t\tlocked && !(locked = false) && onLockAxis && onLockAxis(self);\n\t\t\t\tif (wheeled) {\n\t\t\t\t\tonWheel(self);\n\t\t\t\t\twheeled = false;\n\t\t\t\t}\n\t\t\t\tid = 0;\n\t\t\t},\n\t\t\tonDelta = (x, y, index) => {\n\t\t\t\tdeltaX[index] += x;\n\t\t\t\tdeltaY[index] += y;\n\t\t\t\tself._vx.update(x);\n\t\t\t\tself._vy.update(y);\n\t\t\t\tdebounce ? id || (id = requestAnimationFrame(update)) : update();\n\t\t\t},\n\t\t\tonTouchOrPointerDelta = (x, y) => {\n\t\t\t\tif (lockAxis && !axis) {\n\t\t\t\t\tself.axis = axis = Math.abs(x) > Math.abs(y) ? \"x\" : \"y\";\n\t\t\t\t\tlocked = true;\n\t\t\t\t}\n\t\t\t\tif (axis !== \"y\") {\n\t\t\t\t\tdeltaX[2] += x;\n\t\t\t\t\tself._vx.update(x, true); // update the velocity as frequently as possible instead of in the debounced function so that very quick touch-scrolls (flicks) feel natural. If it's the mouse/touch/pointer, force it so that we get snappy/accurate momentum scroll.\n\t\t\t\t}\n\t\t\t\tif (axis !== \"x\") {\n\t\t\t\t\tdeltaY[2] += y;\n\t\t\t\t\tself._vy.update(y, true);\n\t\t\t\t}\n\t\t\t\tdebounce ? id || (id = requestAnimationFrame(update)) : update();\n\t\t\t},\n\t\t\t_onDrag = e => {\n\t\t\t\tif (_ignoreCheck(e, 1)) {return;}\n\t\t\t\te = _getEvent(e, preventDefault);\n\t\t\t\tlet x = e.clientX,\n\t\t\t\t\ty = e.clientY,\n\t\t\t\t\tdx = x - self.x,\n\t\t\t\t\tdy = y - self.y,\n\t\t\t\t\tisDragging = self.isDragging;\n\t\t\t\tself.x = x;\n\t\t\t\tself.y = y;\n\t\t\t\tif (isDragging || Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum) {\n\t\t\t\t\tonDrag && (dragged = true);\n\t\t\t\t\tisDragging || (self.isDragging = true);\n\t\t\t\t\tonTouchOrPointerDelta(dx, dy);\n\t\t\t\t\tisDragging || onDragStart && onDragStart(self);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_onPress = self.onPress = e => {\n\t\t\t\tif (_ignoreCheck(e, 1) || (e && e.button)) {return;}\n\t\t\t\tself.axis = axis = null;\n\t\t\t\tonStopDelayedCall.pause();\n\t\t\t\tself.isPressed = true;\n\t\t\t\te = _getEvent(e); // note: may need to preventDefault(?) Won't side-scroll on iOS Safari if we do, though.\n\t\t\t\tprevDeltaX = prevDeltaY = 0;\n\t\t\t\tself.startX = self.x = e.clientX;\n\t\t\t\tself.startY = self.y = e.clientY;\n\t\t\t\tself._vx.reset(); // otherwise the t2 may be stale if the user touches and flicks super fast and releases in less than 2 requestAnimationFrame ticks, causing velocity to be 0.\n\t\t\t\tself._vy.reset();\n\t\t\t\t_addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, passive, true);\n\t\t\t\tself.deltaX = self.deltaY = 0;\n\t\t\t\tonPress && onPress(self);\n\t\t\t},\n\t\t\t_onRelease = self.onRelease = e => {\n\t\t\t\tif (_ignoreCheck(e, 1)) {return;}\n\t\t\t\t_removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);\n\t\t\t\tlet isTrackingDrag = !isNaN(self.y - self.startY),\n\t\t\t\t\twasDragging = self.isDragging,\n\t\t\t\t\tisDragNotClick = wasDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3), // some touch devices need some wiggle room in terms of sensing clicks - the finger may move a few pixels.\n\t\t\t\t\teventData = _getEvent(e);\n\t\t\t\tif (!isDragNotClick && isTrackingDrag) {\n\t\t\t\t\tself._vx.reset();\n\t\t\t\t\tself._vy.reset();\n\t\t\t\t\t//if (preventDefault && allowClicks && self.isPressed) { // check isPressed because in a rare edge case, the inputObserver in ScrollTrigger may stopPropagation() on the press/drag, so the onRelease may get fired without the onPress/onDrag ever getting called, thus it could trigger a click to occur on a link after scroll-dragging it.\n\t\t\t\t\tif (preventDefault && allowClicks) {\n\t\t\t\t\t\tgsap.delayedCall(0.08, () => { // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular \"click\" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the \"real\"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the \"real\" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.\n\t\t\t\t\t\t\tif (_getTime() - onClickTime > 300 && !e.defaultPrevented) {\n\t\t\t\t\t\t\t\tif (e.target.click) { //some browsers (like mobile Safari) don't properly trigger the click event\n\t\t\t\t\t\t\t\t\te.target.click();\n\t\t\t\t\t\t\t\t} else if (ownerDoc.createEvent) {\n\t\t\t\t\t\t\t\t\tlet syntheticEvent = ownerDoc.createEvent(\"MouseEvents\");\n\t\t\t\t\t\t\t\t\tsyntheticEvent.initMouseEvent(\"click\", true, true, _win, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, false, false, false, false, 0, null);\n\t\t\t\t\t\t\t\t\te.target.dispatchEvent(syntheticEvent);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tself.isDragging = self.isGesturing = self.isPressed = false;\n\t\t\t\tonStop && wasDragging && !isNormalizer && onStopDelayedCall.restart(true);\n\t\t\t\tonDragEnd && wasDragging && onDragEnd(self);\n\t\t\t\tonRelease && onRelease(self, isDragNotClick);\n\t\t\t},\n\t\t\t_onGestureStart = e => e.touches && e.touches.length > 1 && (self.isGesturing = true) && onGestureStart(e, self.isDragging),\n\t\t\t_onGestureEnd = () => (self.isGesturing = false) || onGestureEnd(self),\n\t\t\tonScroll = e => {\n\t\t\t\tif (_ignoreCheck(e)) {return;}\n\t\t\t\tlet x = scrollFuncX(),\n\t\t\t\t\ty = scrollFuncY();\n\t\t\t\tonDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);\n\t\t\t\tscrollX = x;\n\t\t\t\tscrollY = y;\n\t\t\t\tonStop && onStopDelayedCall.restart(true);\n\t\t\t},\n\t\t\t_onWheel = e => {\n\t\t\t\tif (_ignoreCheck(e)) {return;}\n\t\t\t\te = _getEvent(e, preventDefault);\n\t\t\t\tonWheel && (wheeled = true);\n\t\t\t\tlet multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win.innerHeight : 1) * wheelSpeed;\n\t\t\t\tonDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);\n\t\t\t\tonStop && !isNormalizer && onStopDelayedCall.restart(true);\n\t\t\t},\n\t\t\t_onMove = e => {\n\t\t\t\tif (_ignoreCheck(e)) {return;}\n\t\t\t\tlet x = e.clientX,\n\t\t\t\t\ty = e.clientY,\n\t\t\t\t\tdx = x - self.x,\n\t\t\t\t\tdy = y - self.y;\n\t\t\t\tself.x = x;\n\t\t\t\tself.y = y;\n\t\t\t\tmoved = true;\n\t\t\t\tonStop && onStopDelayedCall.restart(true);\n\t\t\t\t(dx || dy) && onTouchOrPointerDelta(dx, dy);\n\t\t\t},\n\t\t\t_onHover = e => {self.event = e; onHover(self);},\n\t\t\t_onHoverEnd = e => {self.event = e; onHoverEnd(self);},\n\t\t\t_onClick = e => _ignoreCheck(e) || (_getEvent(e, preventDefault) && onClick(self));\n\n\t\tonStopDelayedCall = self._dc = gsap.delayedCall(onStopDelay || 0.25, onStopFunc).pause();\n\n\t\tself.deltaX = self.deltaY = 0;\n\t\tself._vx = _getVelocityProp(0, 50, true);\n\t\tself._vy = _getVelocityProp(0, 50, true);\n\t\tself.scrollX = scrollFuncX;\n\t\tself.scrollY = scrollFuncY;\n\t\tself.isDragging = self.isGesturing = self.isPressed = false;\n\t\t_context(this);\n\t\tself.enable = e => {\n\t\t\tif (!self.isEnabled) {\n\t\t\t\t_addListener(isViewport ? ownerDoc : target, \"scroll\", _onScroll);\n\t\t\t\ttype.indexOf(\"scroll\") >= 0 && _addListener(isViewport ? ownerDoc : target, \"scroll\", onScroll, passive, capture);\n\t\t\t\ttype.indexOf(\"wheel\") >= 0 && _addListener(target, \"wheel\", _onWheel, passive, capture);\n\t\t\t\tif ((type.indexOf(\"touch\") >= 0 && _isTouch) || type.indexOf(\"pointer\") >= 0) {\n\t\t\t\t\t_addListener(target, _eventTypes[0], _onPress, passive, capture);\n\t\t\t\t\t_addListener(ownerDoc, _eventTypes[2], _onRelease);\n\t\t\t\t\t_addListener(ownerDoc, _eventTypes[3], _onRelease);\n\t\t\t\t\tallowClicks && _addListener(target, \"click\", clickCapture, true, true);\n\t\t\t\t\tonClick && _addListener(target, \"click\", _onClick);\n\t\t\t\t\tonGestureStart && _addListener(ownerDoc, \"gesturestart\", _onGestureStart);\n\t\t\t\t\tonGestureEnd && _addListener(ownerDoc, \"gestureend\", _onGestureEnd);\n\t\t\t\t\tonHover && _addListener(target, _pointerType + \"enter\", _onHover);\n\t\t\t\t\tonHoverEnd && _addListener(target, _pointerType + \"leave\", _onHoverEnd);\n\t\t\t\t\tonMove && _addListener(target, _pointerType + \"move\", _onMove);\n\t\t\t\t}\n\t\t\t\tself.isEnabled = true;\n\t\t\t\te && e.type && _onPress(e);\n\t\t\t\tonEnable && onEnable(self);\n\t\t\t}\n\t\t\treturn self;\n\t\t};\n\t\tself.disable = () => {\n\t\t\tif (self.isEnabled) {\n\t\t\t\t// only remove the _onScroll listener if there aren't any others that rely on the functionality.\n\t\t\t\t_observers.filter(o => o !== self && _isViewport(o.target)).length || _removeListener(isViewport ? ownerDoc : target, \"scroll\", _onScroll);\n\t\t\t\tif (self.isPressed) {\n\t\t\t\t\tself._vx.reset();\n\t\t\t\t\tself._vy.reset();\n\t\t\t\t\t_removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, true);\n\t\t\t\t}\n\t\t\t\t_removeListener(isViewport ? ownerDoc : target, \"scroll\", onScroll, capture);\n\t\t\t\t_removeListener(target, \"wheel\", _onWheel, capture);\n\t\t\t\t_removeListener(target, _eventTypes[0], _onPress, capture);\n\t\t\t\t_removeListener(ownerDoc, _eventTypes[2], _onRelease);\n\t\t\t\t_removeListener(ownerDoc, _eventTypes[3], _onRelease);\n\t\t\t\t_removeListener(target, \"click\", clickCapture, true);\n\t\t\t\t_removeListener(target, \"click\", _onClick);\n\t\t\t\t_removeListener(ownerDoc, \"gesturestart\", _onGestureStart);\n\t\t\t\t_removeListener(ownerDoc, \"gestureend\", _onGestureEnd);\n\t\t\t\t_removeListener(target, _pointerType + \"enter\", _onHover);\n\t\t\t\t_removeListener(target, _pointerType + \"leave\", _onHoverEnd);\n\t\t\t\t_removeListener(target, _pointerType + \"move\", _onMove);\n\t\t\t\tself.isEnabled = self.isPressed = self.isDragging = false;\n\t\t\t\tonDisable && onDisable(self);\n\t\t\t}\n\t\t};\n\n\t\tself.kill = self.revert = () => {\n\t\t\tself.disable();\n\t\t\tlet i = _observers.indexOf(self);\n\t\t\ti >= 0 && _observers.splice(i, 1);\n\t\t\t_normalizer === self && (_normalizer = 0);\n\t\t}\n\n\t\t_observers.push(self);\n\t\tisNormalizer && _isViewport(target) && (_normalizer = self);\n\n\t\tself.enable(event);\n\t}\n\n\tget velocityX() {\n\t\treturn this._vx.getVelocity();\n\t}\n\tget velocityY() {\n\t\treturn this._vy.getVelocity();\n\t}\n\n}\n\nObserver.version = \"3.12.5\";\nObserver.create = vars => new Observer(vars);\nObserver.register = _initCore;\nObserver.getAll = () => _observers.slice();\nObserver.getById = id => _observers.filter(o => o.vars.id === id)[0];\n\n_getGSAP() && gsap.registerPlugin(Observer);\n\nexport { Observer as default, _isViewport, _scrollers, _getScrollFunc, _getProxyProp, _proxies, _getVelocityProp, _vertical, _horizontal, _getTarget };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}