{"ast":null,"code":"/*!\n * ScrollToPlugin 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet gsap,\n  _coreInitted,\n  _window,\n  _docEl,\n  _body,\n  _toArray,\n  _config,\n  ScrollTrigger,\n  _windowExists = () => typeof window !== \"undefined\",\n  _getGSAP = () => gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap,\n  _isString = value => typeof value === \"string\",\n  _isFunction = value => typeof value === \"function\",\n  _max = (element, axis) => {\n    let dim = axis === \"x\" ? \"Width\" : \"Height\",\n      scroll = \"scroll\" + dim,\n      client = \"client\" + dim;\n    return element === _window || element === _docEl || element === _body ? Math.max(_docEl[scroll], _body[scroll]) - (_window[\"inner\" + dim] || _docEl[client] || _body[client]) : element[scroll] - element[\"offset\" + dim];\n  },\n  _buildGetter = (e, axis) => {\n    //pass in an element and an axis (\"x\" or \"y\") and it'll return a getter function for the scroll position of that element (like scrollTop or scrollLeft, although if the element is the window, it'll use the pageXOffset/pageYOffset or the documentElement's scrollTop/scrollLeft or document.body's. Basically this streamlines things and makes a very fast getter across browsers.\n    let p = \"scroll\" + (axis === \"x\" ? \"Left\" : \"Top\");\n    if (e === _window) {\n      if (e.pageXOffset != null) {\n        p = \"page\" + axis.toUpperCase() + \"Offset\";\n      } else {\n        e = _docEl[p] != null ? _docEl : _body;\n      }\n    }\n    return () => e[p];\n  },\n  _clean = (value, index, target, targets) => {\n    _isFunction(value) && (value = value(index, target, targets));\n    if (typeof value !== \"object\") {\n      return _isString(value) && value !== \"max\" && value.charAt(1) !== \"=\" ? {\n        x: value,\n        y: value\n      } : {\n        y: value\n      }; //if we don't receive an object as the parameter, assume the user intends \"y\".\n    } else if (value.nodeType) {\n      return {\n        y: value,\n        x: value\n      };\n    } else {\n      let result = {},\n        p;\n      for (p in value) {\n        result[p] = p !== \"onAutoKill\" && _isFunction(value[p]) ? value[p](index, target, targets) : value[p];\n      }\n      return result;\n    }\n  },\n  _getOffset = (element, container) => {\n    element = _toArray(element)[0];\n    if (!element || !element.getBoundingClientRect) {\n      return console.warn(\"scrollTo target doesn't exist. Using 0\") || {\n        x: 0,\n        y: 0\n      };\n    }\n    let rect = element.getBoundingClientRect(),\n      isRoot = !container || container === _window || container === _body,\n      cRect = isRoot ? {\n        top: _docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0),\n        left: _docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0)\n      } : container.getBoundingClientRect(),\n      offsets = {\n        x: rect.left - cRect.left,\n        y: rect.top - cRect.top\n      };\n    if (!isRoot && container) {\n      //only add the current scroll position if it's not the window/body.\n      offsets.x += _buildGetter(container, \"x\")();\n      offsets.y += _buildGetter(container, \"y\")();\n    }\n    return offsets;\n  },\n  _parseVal = (value, target, axis, currentVal, offset) => !isNaN(value) && typeof value !== \"object\" ? parseFloat(value) - offset : _isString(value) && value.charAt(1) === \"=\" ? parseFloat(value.substr(2)) * (value.charAt(0) === \"-\" ? -1 : 1) + currentVal - offset : value === \"max\" ? _max(target, axis) - offset : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset),\n  _initCore = () => {\n    gsap = _getGSAP();\n    if (_windowExists() && gsap && typeof document !== \"undefined\" && document.body) {\n      _window = window;\n      _body = document.body;\n      _docEl = document.documentElement;\n      _toArray = gsap.utils.toArray;\n      gsap.config({\n        autoKillThreshold: 7\n      });\n      _config = gsap.config();\n      _coreInitted = 1;\n    }\n  };\nexport const ScrollToPlugin = {\n  version: \"3.12.5\",\n  name: \"scrollTo\",\n  rawVars: 1,\n  register(core) {\n    gsap = core;\n    _initCore();\n  },\n  init(target, value, tween, index, targets) {\n    _coreInitted || _initCore();\n    let data = this,\n      snapType = gsap.getProperty(target, \"scrollSnapType\");\n    data.isWin = target === _window;\n    data.target = target;\n    data.tween = tween;\n    value = _clean(value, index, target, targets);\n    data.vars = value;\n    data.autoKill = !!value.autoKill;\n    data.getX = _buildGetter(target, \"x\");\n    data.getY = _buildGetter(target, \"y\");\n    data.x = data.xPrev = data.getX();\n    data.y = data.yPrev = data.getY();\n    ScrollTrigger || (ScrollTrigger = gsap.core.globals().ScrollTrigger);\n    gsap.getProperty(target, \"scrollBehavior\") === \"smooth\" && gsap.set(target, {\n      scrollBehavior: \"auto\"\n    });\n    if (snapType && snapType !== \"none\") {\n      // disable scroll snapping to avoid strange behavior\n      data.snap = 1;\n      data.snapInline = target.style.scrollSnapType;\n      target.style.scrollSnapType = \"none\";\n    }\n    if (value.x != null) {\n      data.add(data, \"x\", data.x, _parseVal(value.x, target, \"x\", data.x, value.offsetX || 0), index, targets);\n      data._props.push(\"scrollTo_x\");\n    } else {\n      data.skipX = 1;\n    }\n    if (value.y != null) {\n      data.add(data, \"y\", data.y, _parseVal(value.y, target, \"y\", data.y, value.offsetY || 0), index, targets);\n      data._props.push(\"scrollTo_y\");\n    } else {\n      data.skipY = 1;\n    }\n  },\n  render(ratio, data) {\n    let pt = data._pt,\n      {\n        target,\n        tween,\n        autoKill,\n        xPrev,\n        yPrev,\n        isWin,\n        snap,\n        snapInline\n      } = data,\n      x,\n      y,\n      yDif,\n      xDif,\n      threshold;\n    while (pt) {\n      pt.r(ratio, pt.d);\n      pt = pt._next;\n    }\n    x = isWin || !data.skipX ? data.getX() : xPrev;\n    y = isWin || !data.skipY ? data.getY() : yPrev;\n    yDif = y - yPrev;\n    xDif = x - xPrev;\n    threshold = _config.autoKillThreshold;\n    if (data.x < 0) {\n      //can't scroll to a position less than 0! Might happen if someone uses a Back.easeOut or Elastic.easeOut when scrolling back to the top of the page (for example)\n      data.x = 0;\n    }\n    if (data.y < 0) {\n      data.y = 0;\n    }\n    if (autoKill) {\n      //note: iOS has a bug that throws off the scroll by several pixels, so we need to check if it's within 7 pixels of the previous one that we set instead of just looking for an exact match.\n      if (!data.skipX && (xDif > threshold || xDif < -threshold) && x < _max(target, \"x\")) {\n        data.skipX = 1; //if the user scrolls separately, we should stop tweening!\n      }\n      if (!data.skipY && (yDif > threshold || yDif < -threshold) && y < _max(target, \"y\")) {\n        data.skipY = 1; //if the user scrolls separately, we should stop tweening!\n      }\n      if (data.skipX && data.skipY) {\n        tween.kill();\n        data.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || []);\n      }\n    }\n    if (isWin) {\n      _window.scrollTo(!data.skipX ? data.x : x, !data.skipY ? data.y : y);\n    } else {\n      data.skipY || (target.scrollTop = data.y);\n      data.skipX || (target.scrollLeft = data.x);\n    }\n    if (snap && (ratio === 1 || ratio === 0)) {\n      y = target.scrollTop;\n      x = target.scrollLeft;\n      snapInline ? target.style.scrollSnapType = snapInline : target.style.removeProperty(\"scroll-snap-type\");\n      target.scrollTop = y + 1; // bug in Safari causes the element to totally reset its scroll position when scroll-snap-type changes, so we need to set it to a slightly different value and then back again to work around this bug.\n      target.scrollLeft = x + 1;\n      target.scrollTop = y;\n      target.scrollLeft = x;\n    }\n    data.xPrev = data.x;\n    data.yPrev = data.y;\n    ScrollTrigger && ScrollTrigger.update();\n  },\n  kill(property) {\n    let both = property === \"scrollTo\",\n      i = this._props.indexOf(property);\n    if (both || property === \"scrollTo_x\") {\n      this.skipX = 1;\n    }\n    if (both || property === \"scrollTo_y\") {\n      this.skipY = 1;\n    }\n    i > -1 && this._props.splice(i, 1);\n    return !this._props.length;\n  }\n};\nScrollToPlugin.max = _max;\nScrollToPlugin.getOffset = _getOffset;\nScrollToPlugin.buildGetter = _buildGetter;\n_getGSAP() && gsap.registerPlugin(ScrollToPlugin);\nexport { ScrollToPlugin as default };","map":{"version":3,"names":["gsap","_coreInitted","_window","_docEl","_body","_toArray","_config","ScrollTrigger","_windowExists","window","_getGSAP","registerPlugin","_isString","value","_isFunction","_max","element","axis","dim","scroll","client","Math","max","_buildGetter","e","p","pageXOffset","toUpperCase","_clean","index","target","targets","charAt","x","y","nodeType","result","_getOffset","container","getBoundingClientRect","console","warn","rect","isRoot","cRect","top","clientTop","pageYOffset","scrollTop","left","clientLeft","scrollLeft","offsets","_parseVal","currentVal","offset","isNaN","parseFloat","substr","min","_initCore","document","body","documentElement","utils","toArray","config","autoKillThreshold","ScrollToPlugin","version","name","rawVars","register","core","init","tween","data","snapType","getProperty","isWin","vars","autoKill","getX","getY","xPrev","yPrev","globals","set","scrollBehavior","snap","snapInline","style","scrollSnapType","add","offsetX","_props","push","skipX","offsetY","skipY","render","ratio","pt","_pt","yDif","xDif","threshold","r","d","_next","kill","onAutoKill","apply","onAutoKillParams","scrollTo","removeProperty","update","property","both","i","indexOf","splice","length","getOffset","buildGetter","default"],"sources":["C:/Users/baros/Downloads/GSAP-Crack-master/src/ScrollToPlugin.js"],"sourcesContent":["/*!\n * ScrollToPlugin 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nlet gsap, _coreInitted, _window, _docEl, _body, _toArray, _config, ScrollTrigger,\n\t_windowExists = () => typeof(window) !== \"undefined\",\n\t_getGSAP = () => gsap || (_windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap),\n\t_isString = value => typeof(value) === \"string\",\n\t_isFunction = value => typeof(value) === \"function\",\n\t_max = (element, axis) => {\n\t\tlet dim = (axis === \"x\") ? \"Width\" : \"Height\",\n\t\t\tscroll = \"scroll\" + dim,\n\t\t\tclient = \"client\" + dim;\n\t\treturn (element === _window || element === _docEl || element === _body) ? Math.max(_docEl[scroll], _body[scroll]) - (_window[\"inner\" + dim] || _docEl[client] || _body[client]) : element[scroll] - element[\"offset\" + dim];\n\t},\n\t_buildGetter = (e, axis) => { //pass in an element and an axis (\"x\" or \"y\") and it'll return a getter function for the scroll position of that element (like scrollTop or scrollLeft, although if the element is the window, it'll use the pageXOffset/pageYOffset or the documentElement's scrollTop/scrollLeft or document.body's. Basically this streamlines things and makes a very fast getter across browsers.\n\t\tlet p = \"scroll\" + ((axis === \"x\") ? \"Left\" : \"Top\");\n\t\tif (e === _window) {\n\t\t\tif (e.pageXOffset != null) {\n\t\t\t\tp = \"page\" + axis.toUpperCase() + \"Offset\";\n\t\t\t} else {\n\t\t\t\te = _docEl[p] != null ? _docEl : _body;\n\t\t\t}\n\t\t}\n\t\treturn () => e[p];\n\t},\n\t_clean = (value, index, target, targets) => {\n\t\t_isFunction(value) && (value = value(index, target, targets));\n\t\tif (typeof(value) !== \"object\") {\n\t\t\treturn _isString(value) && value !== \"max\" && value.charAt(1) !== \"=\" ? {x: value, y: value} : {y: value}; //if we don't receive an object as the parameter, assume the user intends \"y\".\n\t\t} else if (value.nodeType) {\n\t\t\treturn {y: value, x: value};\n\t\t} else {\n\t\t\tlet result = {}, p;\n\t\t\tfor (p in value) {\n\t\t\t\tresult[p] = p !== \"onAutoKill\" && _isFunction(value[p]) ? value[p](index, target, targets) : value[p];\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t},\n\t_getOffset = (element, container) => {\n\t\telement = _toArray(element)[0];\n\t\tif (!element || !element.getBoundingClientRect) {\n\t\t\treturn console.warn(\"scrollTo target doesn't exist. Using 0\") || {x:0, y:0};\n\t\t}\n\t\tlet rect = element.getBoundingClientRect(),\n\t\t\tisRoot = (!container || container === _window || container === _body),\n\t\t\tcRect = isRoot ? {top:_docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0), left:_docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0)} : container.getBoundingClientRect(),\n\t\t\toffsets = {x: rect.left - cRect.left, y: rect.top - cRect.top};\n\t\tif (!isRoot && container) { //only add the current scroll position if it's not the window/body.\n\t\t\toffsets.x += _buildGetter(container, \"x\")();\n\t\t\toffsets.y += _buildGetter(container, \"y\")();\n\t\t}\n\t\treturn offsets;\n\t},\n\t_parseVal = (value, target, axis, currentVal, offset) => !isNaN(value) && typeof(value) !== \"object\" ? parseFloat(value) - offset : (_isString(value) && value.charAt(1) === \"=\") ? parseFloat(value.substr(2)) * (value.charAt(0) === \"-\" ? -1 : 1) + currentVal - offset : (value === \"max\") ? _max(target, axis) - offset : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset),\n\t_initCore = () => {\n\t\tgsap = _getGSAP();\n\t\tif (_windowExists() && gsap && typeof(document) !== \"undefined\" && document.body) {\n\t\t\t_window = window;\n\t\t\t_body = document.body;\n\t\t\t_docEl = document.documentElement;\n\t\t\t_toArray = gsap.utils.toArray;\n\t\t\tgsap.config({autoKillThreshold:7});\n\t\t\t_config = gsap.config();\n\t\t\t_coreInitted = 1;\n\t\t}\n\t};\n\n\nexport const ScrollToPlugin = {\n\tversion: \"3.12.5\",\n\tname: \"scrollTo\",\n\trawVars: 1,\n\tregister(core) {\n\t\tgsap = core;\n\t\t_initCore();\n\t},\n\tinit(target, value, tween, index, targets) {\n\t\t_coreInitted || _initCore();\n\t\tlet data = this,\n\t\t\tsnapType = gsap.getProperty(target, \"scrollSnapType\");\n\t\tdata.isWin = (target === _window);\n\t\tdata.target = target;\n\t\tdata.tween = tween;\n\t\tvalue = _clean(value, index, target, targets);\n\t\tdata.vars = value;\n\t\tdata.autoKill = !!value.autoKill;\n\t\tdata.getX = _buildGetter(target, \"x\");\n\t\tdata.getY = _buildGetter(target, \"y\");\n\t\tdata.x = data.xPrev = data.getX();\n\t\tdata.y = data.yPrev = data.getY();\n\t\tScrollTrigger || (ScrollTrigger = gsap.core.globals().ScrollTrigger);\n\t\tgsap.getProperty(target, \"scrollBehavior\") === \"smooth\" && gsap.set(target, {scrollBehavior: \"auto\"});\n\t\tif (snapType && snapType !== \"none\") { // disable scroll snapping to avoid strange behavior\n\t\t\tdata.snap = 1;\n\t\t\tdata.snapInline = target.style.scrollSnapType;\n\t\t\ttarget.style.scrollSnapType = \"none\";\n\t\t}\n\t\tif (value.x != null) {\n\t\t\tdata.add(data, \"x\", data.x, _parseVal(value.x, target, \"x\", data.x, value.offsetX || 0), index, targets);\n\t\t\tdata._props.push(\"scrollTo_x\");\n\t\t} else {\n\t\t\tdata.skipX = 1;\n\t\t}\n\t\tif (value.y != null) {\n\t\t\tdata.add(data, \"y\", data.y, _parseVal(value.y, target, \"y\", data.y, value.offsetY || 0), index, targets);\n\t\t\tdata._props.push(\"scrollTo_y\");\n\t\t} else {\n\t\t\tdata.skipY = 1;\n\t\t}\n\t},\n\trender(ratio, data) {\n\t\tlet pt = data._pt,\n\t\t\t{ target, tween, autoKill, xPrev, yPrev, isWin, snap, snapInline } = data,\n\t\t\tx, y, yDif, xDif, threshold;\n\t\twhile (pt) {\n\t\t\tpt.r(ratio, pt.d);\n\t\t\tpt = pt._next;\n\t\t}\n\t\tx = (isWin || !data.skipX) ? data.getX() : xPrev;\n\t\ty = (isWin || !data.skipY) ? data.getY() : yPrev;\n\t\tyDif = y - yPrev;\n\t\txDif = x - xPrev;\n\t\tthreshold = _config.autoKillThreshold;\n\t\tif (data.x < 0) { //can't scroll to a position less than 0! Might happen if someone uses a Back.easeOut or Elastic.easeOut when scrolling back to the top of the page (for example)\n\t\t\tdata.x = 0;\n\t\t}\n\t\tif (data.y < 0) {\n\t\t\tdata.y = 0;\n\t\t}\n\t\tif (autoKill) {\n\t\t\t//note: iOS has a bug that throws off the scroll by several pixels, so we need to check if it's within 7 pixels of the previous one that we set instead of just looking for an exact match.\n\t\t\tif (!data.skipX && (xDif > threshold || xDif < -threshold) && x < _max(target, \"x\")) {\n\t\t\t\tdata.skipX = 1; //if the user scrolls separately, we should stop tweening!\n\t\t\t}\n\t\t\tif (!data.skipY && (yDif > threshold || yDif < -threshold) && y < _max(target, \"y\")) {\n\t\t\t\tdata.skipY = 1; //if the user scrolls separately, we should stop tweening!\n\t\t\t}\n\t\t\tif (data.skipX && data.skipY) {\n\t\t\t\ttween.kill();\n\t\t\t\tdata.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || []);\n\t\t\t}\n\t\t}\n\t\tif (isWin) {\n\t\t\t_window.scrollTo((!data.skipX) ? data.x : x, (!data.skipY) ? data.y : y);\n\t\t} else {\n\t\t\tdata.skipY || (target.scrollTop = data.y);\n\t\t\tdata.skipX || (target.scrollLeft = data.x);\n\t\t}\n\t\tif (snap && (ratio === 1 || ratio === 0)) {\n\t\t\ty = target.scrollTop;\n\t\t\tx = target.scrollLeft;\n\t\t\tsnapInline ? (target.style.scrollSnapType = snapInline) : target.style.removeProperty(\"scroll-snap-type\");\n\t\t\ttarget.scrollTop = y + 1; // bug in Safari causes the element to totally reset its scroll position when scroll-snap-type changes, so we need to set it to a slightly different value and then back again to work around this bug.\n\t\t\ttarget.scrollLeft = x + 1;\n\t\t\ttarget.scrollTop = y;\n\t\t\ttarget.scrollLeft = x;\n\t\t}\n\t\tdata.xPrev = data.x;\n\t\tdata.yPrev = data.y;\n\t\tScrollTrigger && ScrollTrigger.update();\n\t},\n\tkill(property) {\n\t\tlet both = (property === \"scrollTo\"),\n\t\t\ti = this._props.indexOf(property);\n\t\tif (both || property === \"scrollTo_x\") {\n\t\t\tthis.skipX = 1;\n\t\t}\n\t\tif (both || property === \"scrollTo_y\") {\n\t\t\tthis.skipY = 1;\n\t\t}\n\t\ti > -1 && this._props.splice(i, 1);\n\t\treturn !this._props.length;\n\t}\n};\n\nScrollToPlugin.max = _max;\nScrollToPlugin.getOffset = _getOffset;\nScrollToPlugin.buildGetter = _buildGetter;\n\n_getGSAP() && gsap.registerPlugin(ScrollToPlugin);\n\nexport { ScrollToPlugin as default };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}