{"ast":null,"code":"/*!\n * Flip 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nimport { getGlobalMatrix, _getDocScrollTop, _getDocScrollLeft, Matrix2D, _setDoc, _getCTM } from \"./utils/matrix.js\";\nlet _id = 1,\n  _toArray,\n  gsap,\n  _batch,\n  _batchAction,\n  _body,\n  _closestTenth,\n  _getStyleSaver,\n  _forEachBatch = (batch, name) => batch.actions.forEach(a => a.vars[name] && a.vars[name](a)),\n  _batchLookup = {},\n  _RAD2DEG = 180 / Math.PI,\n  _DEG2RAD = Math.PI / 180,\n  _emptyObj = {},\n  _dashedNameLookup = {},\n  _memoizedRemoveProps = {},\n  _listToArray = list => typeof list === \"string\" ? list.split(\" \").join(\"\").split(\",\") : list,\n  // removes extra spaces contaminating the names, returns an Array.\n  _callbacks = _listToArray(\"onStart,onUpdate,onComplete,onReverseComplete,onInterrupt\"),\n  _removeProps = _listToArray(\"transform,transformOrigin,width,height,position,top,left,opacity,zIndex,maxWidth,maxHeight,minWidth,minHeight\"),\n  _getEl = target => _toArray(target)[0] || console.warn(\"Element not found:\", target),\n  _round = value => Math.round(value * 10000) / 10000 || 0,\n  _toggleClass = (targets, className, action) => targets.forEach(el => el.classList[action](className)),\n  _reserved = {\n    zIndex: 1,\n    kill: 1,\n    simple: 1,\n    spin: 1,\n    clearProps: 1,\n    targets: 1,\n    toggleClass: 1,\n    onComplete: 1,\n    onUpdate: 1,\n    onInterrupt: 1,\n    onStart: 1,\n    delay: 1,\n    repeat: 1,\n    repeatDelay: 1,\n    yoyo: 1,\n    scale: 1,\n    fade: 1,\n    absolute: 1,\n    props: 1,\n    onEnter: 1,\n    onLeave: 1,\n    custom: 1,\n    paused: 1,\n    nested: 1,\n    prune: 1,\n    absoluteOnLeave: 1\n  },\n  _fitReserved = {\n    zIndex: 1,\n    simple: 1,\n    clearProps: 1,\n    scale: 1,\n    absolute: 1,\n    fitChild: 1,\n    getVars: 1,\n    props: 1\n  },\n  _camelToDashed = p => p.replace(/([A-Z])/g, \"-$1\").toLowerCase(),\n  _copy = (obj, exclude) => {\n    let result = {},\n      p;\n    for (p in obj) {\n      exclude[p] || (result[p] = obj[p]);\n    }\n    return result;\n  },\n  _memoizedProps = {},\n  _memoizeProps = props => {\n    let p = _memoizedProps[props] = _listToArray(props);\n    _memoizedRemoveProps[props] = p.concat(_removeProps);\n    return p;\n  },\n  _getInverseGlobalMatrix = el => {\n    // integrates caching for improved performance\n    let cache = el._gsap || gsap.core.getCache(el);\n    if (cache.gmCache === gsap.ticker.frame) {\n      return cache.gMatrix;\n    }\n    cache.gmCache = gsap.ticker.frame;\n    return cache.gMatrix = getGlobalMatrix(el, true, false, true);\n  },\n  _getDOMDepth = (el, invert, level = 0) => {\n    // In invert is true, the sibling depth is increments of 1, and parent/nesting depth is increments of 1000. This lets us order elements in an Array to reflect document flow.\n    let parent = el.parentNode,\n      inc = 1000 * 10 ** level * (invert ? -1 : 1),\n      l = invert ? -inc * 900 : 0;\n    while (el) {\n      l += inc;\n      el = el.previousSibling;\n    }\n    return parent ? l + _getDOMDepth(parent, invert, level + 1) : l;\n  },\n  _orderByDOMDepth = (comps, invert, isElStates) => {\n    comps.forEach(comp => comp.d = _getDOMDepth(isElStates ? comp.element : comp.t, invert));\n    comps.sort((c1, c2) => c1.d - c2.d);\n    return comps;\n  },\n  _recordInlineStyles = (elState, props) => {\n    // records the current inline CSS properties into an Array in alternating name/value pairs that's stored in a \"css\" property on the state object so that we can revert later.\n    let style = elState.element.style,\n      a = elState.css = elState.css || [],\n      i = props.length,\n      p,\n      v;\n    while (i--) {\n      p = props[i];\n      v = style[p] || style.getPropertyValue(p);\n      a.push(v ? p : _dashedNameLookup[p] || (_dashedNameLookup[p] = _camelToDashed(p)), v);\n    }\n    return style;\n  },\n  _applyInlineStyles = state => {\n    let css = state.css,\n      style = state.element.style,\n      i = 0;\n    state.cache.uncache = 1;\n    for (; i < css.length; i += 2) {\n      css[i + 1] ? style[css[i]] = css[i + 1] : style.removeProperty(css[i]);\n    }\n    if (!css[css.indexOf(\"transform\") + 1] && style.translate) {\n      // CSSPlugin adds scale, translate, and rotate inline CSS as \"none\" in order to keep CSS rules from contaminating transforms.\n      style.removeProperty(\"translate\");\n      style.removeProperty(\"scale\");\n      style.removeProperty(\"rotate\");\n    }\n  },\n  _setFinalStates = (comps, onlyTransforms) => {\n    comps.forEach(c => c.a.cache.uncache = 1);\n    onlyTransforms || comps.finalStates.forEach(_applyInlineStyles);\n  },\n  _absoluteProps = \"paddingTop,paddingRight,paddingBottom,paddingLeft,gridArea,transition\".split(\",\"),\n  // properties that we must record just\n  _makeAbsolute = (elState, fallbackNode, ignoreBatch) => {\n    let {\n        element,\n        width,\n        height,\n        uncache,\n        getProp\n      } = elState,\n      style = element.style,\n      i = 4,\n      result,\n      displayIsNone,\n      cs;\n    typeof fallbackNode !== \"object\" && (fallbackNode = elState);\n    if (_batch && ignoreBatch !== 1) {\n      _batch._abs.push({\n        t: element,\n        b: elState,\n        a: elState,\n        sd: 0\n      });\n      _batch._final.push(() => (elState.cache.uncache = 1) && _applyInlineStyles(elState));\n      return element;\n    }\n    displayIsNone = getProp(\"display\") === \"none\";\n    if (!elState.isVisible || displayIsNone) {\n      displayIsNone && (_recordInlineStyles(elState, [\"display\"]).display = fallbackNode.display);\n      elState.matrix = fallbackNode.matrix;\n      elState.width = width = elState.width || fallbackNode.width;\n      elState.height = height = elState.height || fallbackNode.height;\n    }\n    _recordInlineStyles(elState, _absoluteProps);\n    cs = window.getComputedStyle(element);\n    while (i--) {\n      style[_absoluteProps[i]] = cs[_absoluteProps[i]]; // record paddings as px-based because if removed from grid, percentage-based ones could be altered.\n    }\n    style.gridArea = \"1 / 1 / 1 / 1\";\n    style.transition = \"none\";\n    style.position = \"absolute\";\n    style.width = width + \"px\";\n    style.height = height + \"px\";\n    style.top || (style.top = \"0px\");\n    style.left || (style.left = \"0px\");\n    if (uncache) {\n      result = new ElementState(element);\n    } else {\n      // better performance\n      result = _copy(elState, _emptyObj);\n      result.position = \"absolute\";\n      if (elState.simple) {\n        let bounds = element.getBoundingClientRect();\n        result.matrix = new Matrix2D(1, 0, 0, 1, bounds.left + _getDocScrollLeft(), bounds.top + _getDocScrollTop());\n      } else {\n        result.matrix = getGlobalMatrix(element, false, false, true);\n      }\n    }\n    result = _fit(result, elState, true);\n    elState.x = _closestTenth(result.x, 0.01);\n    elState.y = _closestTenth(result.y, 0.01);\n    return element;\n  },\n  _filterComps = (comps, targets) => {\n    if (targets !== true) {\n      targets = _toArray(targets);\n      comps = comps.filter(c => {\n        if (targets.indexOf((c.sd < 0 ? c.b : c.a).element) !== -1) {\n          return true;\n        } else {\n          c.t._gsap.renderTransform(1); // we must force transforms to render on anything that isn't being made position: absolute, otherwise the absolute position happens and then when animation begins it applies transforms which can create a new stacking context, throwing off positioning!\n          if (c.b.isVisible) {\n            c.t.style.width = c.b.width + \"px\"; // otherwise things can collapse when contents are made position: absolute.\n            c.t.style.height = c.b.height + \"px\";\n          }\n        }\n      });\n    }\n    return comps;\n  },\n  _makeCompsAbsolute = comps => _orderByDOMDepth(comps, true).forEach(c => (c.a.isVisible || c.b.isVisible) && _makeAbsolute(c.sd < 0 ? c.b : c.a, c.b, 1)),\n  _findElStateInState = (state, other) => other && state.idLookup[_parseElementState(other).id] || state.elementStates[0],\n  _parseElementState = (elOrNode, props, simple, other) => elOrNode instanceof ElementState ? elOrNode : elOrNode instanceof FlipState ? _findElStateInState(elOrNode, other) : new ElementState(typeof elOrNode === \"string\" ? _getEl(elOrNode) || console.warn(elOrNode + \" not found\") : elOrNode, props, simple),\n  _recordProps = (elState, props) => {\n    let getProp = gsap.getProperty(elState.element, null, \"native\"),\n      obj = elState.props = {},\n      i = props.length;\n    while (i--) {\n      obj[props[i]] = (getProp(props[i]) + \"\").trim();\n    }\n    obj.zIndex && (obj.zIndex = parseFloat(obj.zIndex) || 0);\n    return elState;\n  },\n  _applyProps = (element, props) => {\n    let style = element.style || element,\n      // could pass in a vars object.\n      p;\n    for (p in props) {\n      style[p] = props[p];\n    }\n  },\n  _getID = el => {\n    let id = el.getAttribute(\"data-flip-id\");\n    id || el.setAttribute(\"data-flip-id\", id = \"auto-\" + _id++);\n    return id;\n  },\n  _elementsFromElementStates = elStates => elStates.map(elState => elState.element),\n  _handleCallback = (callback, elStates, tl) => callback && elStates.length && tl.add(callback(_elementsFromElementStates(elStates), tl, new FlipState(elStates, 0, true)), 0),\n  _fit = (fromState, toState, scale, applyProps, fitChild, vars) => {\n    let {\n        element,\n        cache,\n        parent,\n        x,\n        y\n      } = fromState,\n      {\n        width,\n        height,\n        scaleX,\n        scaleY,\n        rotation,\n        bounds\n      } = toState,\n      styles = vars && _getStyleSaver && _getStyleSaver(element, \"transform\"),\n      // requires at least 3.11.5\n      dimensionState = fromState,\n      {\n        e,\n        f\n      } = toState.matrix,\n      deep = fromState.bounds.width !== bounds.width || fromState.bounds.height !== bounds.height || fromState.scaleX !== scaleX || fromState.scaleY !== scaleY || fromState.rotation !== rotation,\n      simple = !deep && fromState.simple && toState.simple && !fitChild,\n      skewX,\n      fromPoint,\n      toPoint,\n      getProp,\n      parentMatrix,\n      matrix,\n      bbox;\n    if (simple || !parent) {\n      scaleX = scaleY = 1;\n      rotation = skewX = 0;\n    } else {\n      parentMatrix = _getInverseGlobalMatrix(parent);\n      matrix = parentMatrix.clone().multiply(toState.ctm ? toState.matrix.clone().multiply(toState.ctm) : toState.matrix); // root SVG elements have a ctm that we must factor out (for example, viewBox:\"0 0 94 94\" with a width of 200px would scale the internals by 2.127 but when we're matching the size of the root <svg> element itself, that scaling shouldn't factor in!)\n      rotation = _round(Math.atan2(matrix.b, matrix.a) * _RAD2DEG);\n      skewX = _round(Math.atan2(matrix.c, matrix.d) * _RAD2DEG + rotation) % 360; // in very rare cases, minor rounding might end up with 360 which should be 0.\n      scaleX = Math.sqrt(matrix.a ** 2 + matrix.b ** 2);\n      scaleY = Math.sqrt(matrix.c ** 2 + matrix.d ** 2) * Math.cos(skewX * _DEG2RAD);\n      if (fitChild) {\n        fitChild = _toArray(fitChild)[0];\n        getProp = gsap.getProperty(fitChild);\n        bbox = fitChild.getBBox && typeof fitChild.getBBox === \"function\" && fitChild.getBBox();\n        dimensionState = {\n          scaleX: getProp(\"scaleX\"),\n          scaleY: getProp(\"scaleY\"),\n          width: bbox ? bbox.width : Math.ceil(parseFloat(getProp(\"width\", \"px\"))),\n          height: bbox ? bbox.height : parseFloat(getProp(\"height\", \"px\"))\n        };\n      }\n      cache.rotation = rotation + \"deg\";\n      cache.skewX = skewX + \"deg\";\n    }\n    if (scale) {\n      scaleX *= width === dimensionState.width || !dimensionState.width ? 1 : width / dimensionState.width; // note if widths are both 0, we should make scaleX 1 - some elements have box-sizing that incorporates padding, etc. and we don't want it to collapse in that case.\n      scaleY *= height === dimensionState.height || !dimensionState.height ? 1 : height / dimensionState.height;\n      cache.scaleX = scaleX;\n      cache.scaleY = scaleY;\n    } else {\n      width = _closestTenth(width * scaleX / dimensionState.scaleX, 0);\n      height = _closestTenth(height * scaleY / dimensionState.scaleY, 0);\n      element.style.width = width + \"px\";\n      element.style.height = height + \"px\";\n    }\n    // if (fromState.isFixed) { // commented out because it's now taken care of in getGlobalMatrix() with a flag at the end.\n    // \te -= _getDocScrollLeft();\n    // \tf -= _getDocScrollTop();\n    // }\n    applyProps && _applyProps(element, toState.props);\n    if (simple || !parent) {\n      x += e - fromState.matrix.e;\n      y += f - fromState.matrix.f;\n    } else if (deep || parent !== toState.parent) {\n      cache.renderTransform(1, cache);\n      matrix = getGlobalMatrix(fitChild || element, false, false, true);\n      fromPoint = parentMatrix.apply({\n        x: matrix.e,\n        y: matrix.f\n      });\n      toPoint = parentMatrix.apply({\n        x: e,\n        y: f\n      });\n      x += toPoint.x - fromPoint.x;\n      y += toPoint.y - fromPoint.y;\n    } else {\n      // use a faster/cheaper algorithm if we're just moving x/y\n      parentMatrix.e = parentMatrix.f = 0;\n      toPoint = parentMatrix.apply({\n        x: e - fromState.matrix.e,\n        y: f - fromState.matrix.f\n      });\n      x += toPoint.x;\n      y += toPoint.y;\n    }\n    x = _closestTenth(x, 0.02);\n    y = _closestTenth(y, 0.02);\n    if (vars && !(vars instanceof ElementState)) {\n      // revert\n      styles && styles.revert();\n    } else {\n      // or apply the transform immediately\n      cache.x = x + \"px\";\n      cache.y = y + \"px\";\n      cache.renderTransform(1, cache);\n    }\n    if (vars) {\n      vars.x = x;\n      vars.y = y;\n      vars.rotation = rotation;\n      vars.skewX = skewX;\n      if (scale) {\n        vars.scaleX = scaleX;\n        vars.scaleY = scaleY;\n      } else {\n        vars.width = width;\n        vars.height = height;\n      }\n    }\n    return vars || cache;\n  },\n  _parseState = (targetsOrState, vars) => targetsOrState instanceof FlipState ? targetsOrState : new FlipState(targetsOrState, vars),\n  _getChangingElState = (toState, fromState, id) => {\n    let to1 = toState.idLookup[id],\n      to2 = toState.alt[id];\n    return to2.isVisible && (!(fromState.getElementState(to2.element) || to2).isVisible || !to1.isVisible) ? to2 : to1;\n  },\n  _bodyMetrics = [],\n  _bodyProps = \"width,height,overflowX,overflowY\".split(\",\"),\n  _bodyLocked,\n  _lockBodyScroll = lock => {\n    // if there's no scrollbar, we should lock that so that measurements don't get affected by temporary repositioning, like if something is centered in the window.\n    if (lock !== _bodyLocked) {\n      let s = _body.style,\n        w = _body.clientWidth === window.outerWidth,\n        h = _body.clientHeight === window.outerHeight,\n        i = 4;\n      if (lock && (w || h)) {\n        while (i--) {\n          _bodyMetrics[i] = s[_bodyProps[i]];\n        }\n        if (w) {\n          s.width = _body.clientWidth + \"px\";\n          s.overflowY = \"hidden\";\n        }\n        if (h) {\n          s.height = _body.clientHeight + \"px\";\n          s.overflowX = \"hidden\";\n        }\n        _bodyLocked = lock;\n      } else if (_bodyLocked) {\n        while (i--) {\n          _bodyMetrics[i] ? s[_bodyProps[i]] = _bodyMetrics[i] : s.removeProperty(_camelToDashed(_bodyProps[i]));\n        }\n        _bodyLocked = lock;\n      }\n    }\n  },\n  _fromTo = (fromState, toState, vars, relative) => {\n    // relative is -1 if \"from()\", and 1 if \"to()\"\n    fromState instanceof FlipState && toState instanceof FlipState || console.warn(\"Not a valid state object.\");\n    vars = vars || {};\n    let {\n        clearProps,\n        onEnter,\n        onLeave,\n        absolute,\n        absoluteOnLeave,\n        custom,\n        delay,\n        paused,\n        repeat,\n        repeatDelay,\n        yoyo,\n        toggleClass,\n        nested,\n        zIndex,\n        scale,\n        fade,\n        stagger,\n        spin,\n        prune\n      } = vars,\n      props = (\"props\" in vars ? vars : fromState).props,\n      tweenVars = _copy(vars, _reserved),\n      animation = gsap.timeline({\n        delay,\n        paused,\n        repeat,\n        repeatDelay,\n        yoyo,\n        data: \"isFlip\"\n      }),\n      remainingProps = tweenVars,\n      entering = [],\n      leaving = [],\n      comps = [],\n      swapOutTargets = [],\n      spinNum = spin === true ? 1 : spin || 0,\n      spinFunc = typeof spin === \"function\" ? spin : () => spinNum,\n      interrupted = fromState.interrupted || toState.interrupted,\n      addFunc = animation[relative !== 1 ? \"to\" : \"from\"],\n      v,\n      p,\n      endTime,\n      i,\n      el,\n      comp,\n      state,\n      targets,\n      finalStates,\n      fromNode,\n      toNode,\n      run,\n      a,\n      b;\n    //relative || (toState = (new FlipState(toState.targets, {props: props})).fit(toState, scale));\n    for (p in toState.idLookup) {\n      toNode = !toState.alt[p] ? toState.idLookup[p] : _getChangingElState(toState, fromState, p);\n      el = toNode.element;\n      fromNode = fromState.idLookup[p];\n      fromState.alt[p] && el === fromNode.element && (fromState.alt[p].isVisible || !toNode.isVisible) && (fromNode = fromState.alt[p]);\n      if (fromNode) {\n        comp = {\n          t: el,\n          b: fromNode,\n          a: toNode,\n          sd: fromNode.element === el ? 0 : toNode.isVisible ? 1 : -1\n        };\n        comps.push(comp);\n        if (comp.sd) {\n          if (comp.sd < 0) {\n            comp.b = toNode;\n            comp.a = fromNode;\n          }\n          // for swapping elements that got interrupted, we must re-record the inline styles to ensure they're not tainted. Remember, .batch() permits getState() not to force in-progress flips to their end state.\n          interrupted && _recordInlineStyles(comp.b, props ? _memoizedRemoveProps[props] : _removeProps);\n          fade && comps.push(comp.swap = {\n            t: fromNode.element,\n            b: comp.b,\n            a: comp.a,\n            sd: -comp.sd,\n            swap: comp\n          });\n        }\n        el._flip = fromNode.element._flip = _batch ? _batch.timeline : animation;\n      } else if (toNode.isVisible) {\n        comps.push({\n          t: el,\n          b: _copy(toNode, {\n            isVisible: 1\n          }),\n          a: toNode,\n          sd: 0,\n          entering: 1\n        }); // to include it in the \"entering\" Array and do absolute positioning if necessary\n        el._flip = _batch ? _batch.timeline : animation;\n      }\n    }\n    props && (_memoizedProps[props] || _memoizeProps(props)).forEach(p => tweenVars[p] = i => comps[i].a.props[p]);\n    comps.finalStates = finalStates = [];\n    run = () => {\n      _orderByDOMDepth(comps);\n      _lockBodyScroll(true); // otherwise, measurements may get thrown off when things get fit.\n      // TODO: cache the matrix, especially for parent because it'll probably get reused quite a bit, but lock it to a particular cycle(?).\n      for (i = 0; i < comps.length; i++) {\n        comp = comps[i];\n        a = comp.a;\n        b = comp.b;\n        if (prune && !a.isDifferent(b) && !comp.entering) {\n          // only flip if things changed! Don't omit it from comps initially because that'd prevent the element from being positioned absolutely (if necessary)\n          comps.splice(i--, 1);\n        } else {\n          el = comp.t;\n          nested && !(comp.sd < 0) && i && (a.matrix = getGlobalMatrix(el, false, false, true)); // moving a parent affects the position of children\n          if (b.isVisible && a.isVisible) {\n            if (comp.sd < 0) {\n              // swapping OUT (swap direction of -1 is out)\n              state = new ElementState(el, props, fromState.simple);\n              _fit(state, a, scale, 0, 0, state);\n              state.matrix = getGlobalMatrix(el, false, false, true);\n              state.css = comp.b.css;\n              comp.a = a = state;\n              fade && (el.style.opacity = interrupted ? b.opacity : a.opacity);\n              stagger && swapOutTargets.push(el);\n            } else if (comp.sd > 0 && fade) {\n              // swapping IN (swap direction of 1 is in)\n              el.style.opacity = interrupted ? a.opacity - b.opacity : \"0\";\n            }\n            _fit(a, b, scale, props);\n          } else if (b.isVisible !== a.isVisible) {\n            // either entering or leaving (one side is invisible)\n            if (!b.isVisible) {\n              // entering\n              a.isVisible && entering.push(a);\n              comps.splice(i--, 1);\n            } else if (!a.isVisible) {\n              // leaving\n              b.css = a.css;\n              leaving.push(b);\n              comps.splice(i--, 1);\n              absolute && nested && _fit(a, b, scale, props);\n            }\n          }\n          if (!scale) {\n            el.style.maxWidth = Math.max(a.width, b.width) + \"px\";\n            el.style.maxHeight = Math.max(a.height, b.height) + \"px\";\n            el.style.minWidth = Math.min(a.width, b.width) + \"px\";\n            el.style.minHeight = Math.min(a.height, b.height) + \"px\";\n          }\n          nested && toggleClass && el.classList.add(toggleClass);\n        }\n        finalStates.push(a);\n      }\n      let classTargets;\n      if (toggleClass) {\n        classTargets = finalStates.map(s => s.element);\n        nested && classTargets.forEach(e => e.classList.remove(toggleClass)); // there could be a delay, so don't leave the classes applied (we'll do it in a timeline callback)\n      }\n      _lockBodyScroll(false);\n      if (scale) {\n        tweenVars.scaleX = i => comps[i].a.scaleX;\n        tweenVars.scaleY = i => comps[i].a.scaleY;\n      } else {\n        tweenVars.width = i => comps[i].a.width + \"px\";\n        tweenVars.height = i => comps[i].a.height + \"px\";\n        tweenVars.autoRound = vars.autoRound || false;\n      }\n      tweenVars.x = i => comps[i].a.x + \"px\";\n      tweenVars.y = i => comps[i].a.y + \"px\";\n      tweenVars.rotation = i => comps[i].a.rotation + (spin ? spinFunc(i, targets[i], targets) * 360 : 0);\n      tweenVars.skewX = i => comps[i].a.skewX;\n      targets = comps.map(c => c.t);\n      if (zIndex || zIndex === 0) {\n        tweenVars.modifiers = {\n          zIndex: () => zIndex\n        };\n        tweenVars.zIndex = zIndex;\n        tweenVars.immediateRender = vars.immediateRender !== false;\n      }\n      fade && (tweenVars.opacity = i => comps[i].sd < 0 ? 0 : comps[i].sd > 0 ? comps[i].a.opacity : \"+=0\");\n      if (swapOutTargets.length) {\n        stagger = gsap.utils.distribute(stagger);\n        let dummyArray = targets.slice(swapOutTargets.length);\n        tweenVars.stagger = (i, el) => stagger(~swapOutTargets.indexOf(el) ? targets.indexOf(comps[i].swap.t) : i, el, dummyArray);\n      }\n\n      // // for testing...\n      // gsap.delayedCall(vars.data ? 50 : 1, function() {\n      // \tanimation.eventCallback(\"onComplete\", () => _setFinalStates(comps, !clearProps));\n      // \taddFunc.call(animation, targets, tweenVars, 0).play();\n      // });\n      // return;\n\n      _callbacks.forEach(name => vars[name] && animation.eventCallback(name, vars[name], vars[name + \"Params\"])); // apply callbacks to the timeline, not tweens (because \"custom\" timing can make multiple tweens)\n\n      if (custom && targets.length) {\n        // bust out the custom properties as their own tweens so they can use different eases, durations, etc.\n        remainingProps = _copy(tweenVars, _reserved);\n        if (\"scale\" in custom) {\n          custom.scaleX = custom.scaleY = custom.scale;\n          delete custom.scale;\n        }\n        for (p in custom) {\n          v = _copy(custom[p], _fitReserved);\n          v[p] = tweenVars[p];\n          !(\"duration\" in v) && \"duration\" in tweenVars && (v.duration = tweenVars.duration);\n          v.stagger = tweenVars.stagger;\n          addFunc.call(animation, targets, v, 0);\n          delete remainingProps[p];\n        }\n      }\n      if (targets.length || leaving.length || entering.length) {\n        toggleClass && animation.add(() => _toggleClass(classTargets, toggleClass, animation._zTime < 0 ? \"remove\" : \"add\"), 0) && !paused && _toggleClass(classTargets, toggleClass, \"add\");\n        targets.length && addFunc.call(animation, targets, remainingProps, 0);\n      }\n      _handleCallback(onEnter, entering, animation);\n      _handleCallback(onLeave, leaving, animation);\n      let batchTl = _batch && _batch.timeline;\n      if (batchTl) {\n        batchTl.add(animation, 0);\n        _batch._final.push(() => _setFinalStates(comps, !clearProps));\n      }\n      endTime = animation.duration();\n      animation.call(() => {\n        let forward = animation.time() >= endTime;\n        forward && !batchTl && _setFinalStates(comps, !clearProps);\n        toggleClass && _toggleClass(classTargets, toggleClass, forward ? \"remove\" : \"add\");\n      });\n    };\n    absoluteOnLeave && (absolute = comps.filter(comp => !comp.sd && !comp.a.isVisible && comp.b.isVisible).map(comp => comp.a.element));\n    if (_batch) {\n      absolute && _batch._abs.push(..._filterComps(comps, absolute));\n      _batch._run.push(run);\n    } else {\n      absolute && _makeCompsAbsolute(_filterComps(comps, absolute)); // when making absolute, we must go in a very particular order so that document flow changes don't affect things. Don't make it visible if both the before and after states are invisible! There's no point, and it could make things appear visible during the flip that shouldn't be.\n      run();\n    }\n    let anim = _batch ? _batch.timeline : animation;\n    anim.revert = () => _killFlip(anim, 1, 1); // a Flip timeline should behave very different when reverting - it should actually jump to the end so that styles get cleared out.\n\n    return anim;\n  },\n  _interrupt = tl => {\n    tl.vars.onInterrupt && tl.vars.onInterrupt.apply(tl, tl.vars.onInterruptParams || []);\n    tl.getChildren(true, false, true).forEach(_interrupt);\n  },\n  _killFlip = (tl, action, force) => {\n    // action: 0 = nothing, 1 = complete, 2 = only kill (don't complete)\n    if (tl && tl.progress() < 1 && (!tl.paused() || force)) {\n      if (action) {\n        _interrupt(tl);\n        action < 2 && tl.progress(1); // we should also kill it in case it was added to a parent timeline.\n        tl.kill();\n      }\n      return true;\n    }\n  },\n  _createLookup = state => {\n    let lookup = state.idLookup = {},\n      alt = state.alt = {},\n      elStates = state.elementStates,\n      i = elStates.length,\n      elState;\n    while (i--) {\n      elState = elStates[i];\n      lookup[elState.id] ? alt[elState.id] = elState : lookup[elState.id] = elState;\n    }\n  };\nclass FlipState {\n  constructor(targets, vars, targetsAreElementStates) {\n    this.props = vars && vars.props;\n    this.simple = !!(vars && vars.simple);\n    if (targetsAreElementStates) {\n      this.targets = _elementsFromElementStates(targets);\n      this.elementStates = targets;\n      _createLookup(this);\n    } else {\n      this.targets = _toArray(targets);\n      let soft = vars && (vars.kill === false || vars.batch && !vars.kill);\n      _batch && !soft && _batch._kill.push(this);\n      this.update(soft || !!_batch); // when batching, don't force in-progress flips to their end; we need to do that AFTER all getStates() are called.\n    }\n  }\n  update(soft) {\n    this.elementStates = this.targets.map(el => new ElementState(el, this.props, this.simple));\n    _createLookup(this);\n    this.interrupt(soft);\n    this.recordInlineStyles();\n    return this;\n  }\n  clear() {\n    this.targets.length = this.elementStates.length = 0;\n    _createLookup(this);\n    return this;\n  }\n  fit(state, scale, nested) {\n    let elStatesInOrder = _orderByDOMDepth(this.elementStates.slice(0), false, true),\n      toElStates = (state || this).idLookup,\n      i = 0,\n      fromNode,\n      toNode;\n    for (; i < elStatesInOrder.length; i++) {\n      fromNode = elStatesInOrder[i];\n      nested && (fromNode.matrix = getGlobalMatrix(fromNode.element, false, false, true)); // moving a parent affects the position of children\n      toNode = toElStates[fromNode.id];\n      toNode && _fit(fromNode, toNode, scale, true, 0, fromNode);\n      fromNode.matrix = getGlobalMatrix(fromNode.element, false, false, true);\n    }\n    return this;\n  }\n  getProperty(element, property) {\n    let es = this.getElementState(element) || _emptyObj;\n    return (property in es ? es : es.props || _emptyObj)[property];\n  }\n  add(state) {\n    let i = state.targets.length,\n      lookup = this.idLookup,\n      alt = this.alt,\n      index,\n      es,\n      es2;\n    while (i--) {\n      es = state.elementStates[i];\n      es2 = lookup[es.id];\n      if (es2 && (es.element === es2.element || alt[es.id] && alt[es.id].element === es.element)) {\n        // if the flip id is already in this FlipState, replace it!\n        index = this.elementStates.indexOf(es.element === es2.element ? es2 : alt[es.id]);\n        this.targets.splice(index, 1, state.targets[i]);\n        this.elementStates.splice(index, 1, es);\n      } else {\n        this.targets.push(state.targets[i]);\n        this.elementStates.push(es);\n      }\n    }\n    state.interrupted && (this.interrupted = true);\n    state.simple || (this.simple = false);\n    _createLookup(this);\n    return this;\n  }\n  compare(state) {\n    let l1 = state.idLookup,\n      l2 = this.idLookup,\n      unchanged = [],\n      changed = [],\n      enter = [],\n      leave = [],\n      targets = [],\n      a1 = state.alt,\n      a2 = this.alt,\n      place = (s1, s2, el) => (s1.isVisible !== s2.isVisible ? s1.isVisible ? enter : leave : s1.isVisible ? changed : unchanged).push(el) && targets.push(el),\n      placeIfDoesNotExist = (s1, s2, el) => targets.indexOf(el) < 0 && place(s1, s2, el),\n      s1,\n      s2,\n      p,\n      el,\n      s1Alt,\n      s2Alt,\n      c1,\n      c2;\n    for (p in l1) {\n      s1Alt = a1[p];\n      s2Alt = a2[p];\n      s1 = !s1Alt ? l1[p] : _getChangingElState(state, this, p);\n      el = s1.element;\n      s2 = l2[p];\n      if (s2Alt) {\n        c2 = s2.isVisible || !s2Alt.isVisible && el === s2.element ? s2 : s2Alt;\n        c1 = s1Alt && !s1.isVisible && !s1Alt.isVisible && c2.element === s1Alt.element ? s1Alt : s1;\n        //c1.element !== c2.element && c1.element === s2.element && (c2 = s2);\n        if (c1.isVisible && c2.isVisible && c1.element !== c2.element) {\n          // swapping, so force into \"changed\" array\n          (c1.isDifferent(c2) ? changed : unchanged).push(c1.element, c2.element);\n          targets.push(c1.element, c2.element);\n        } else {\n          place(c1, c2, c1.element);\n        }\n        s1Alt && c1.element === s1Alt.element && (s1Alt = l1[p]);\n        placeIfDoesNotExist(c1.element !== s2.element && s1Alt ? s1Alt : c1, s2, s2.element);\n        placeIfDoesNotExist(s1Alt && s1Alt.element === s2Alt.element ? s1Alt : c1, s2Alt, s2Alt.element);\n        s1Alt && placeIfDoesNotExist(s1Alt, s2Alt.element === s1Alt.element ? s2Alt : s2, s1Alt.element);\n      } else {\n        !s2 ? enter.push(el) : !s2.isDifferent(s1) ? unchanged.push(el) : place(s1, s2, el);\n        s1Alt && placeIfDoesNotExist(s1Alt, s2, s1Alt.element);\n      }\n    }\n    for (p in l2) {\n      if (!l1[p]) {\n        leave.push(l2[p].element);\n        a2[p] && leave.push(a2[p].element);\n      }\n    }\n    return {\n      changed,\n      unchanged,\n      enter,\n      leave\n    };\n  }\n  recordInlineStyles() {\n    let props = _memoizedRemoveProps[this.props] || _removeProps,\n      i = this.elementStates.length;\n    while (i--) {\n      _recordInlineStyles(this.elementStates[i], props);\n    }\n  }\n  interrupt(soft) {\n    // soft = DON'T force in-progress flip animations to completion (like when running a batch, we can't immediately kill flips when getting states because it could contaminate positioning and other .getState() calls that will run in the batch (we kill AFTER all the .getState() calls complete).\n    let timelines = [];\n    this.targets.forEach(t => {\n      let tl = t._flip,\n        foundInProgress = _killFlip(tl, soft ? 0 : 1);\n      soft && foundInProgress && timelines.indexOf(tl) < 0 && tl.add(() => this.updateVisibility());\n      foundInProgress && timelines.push(tl);\n    });\n    !soft && timelines.length && this.updateVisibility(); // if we found an in-progress Flip animation, we must record all the values in their current state at that point BUT we should update the isVisible value AFTER pushing that flip to completion so that elements that are entering or leaving will populate those Arrays properly.\n    this.interrupted || (this.interrupted = !!timelines.length);\n  }\n  updateVisibility() {\n    this.elementStates.forEach(es => {\n      let b = es.element.getBoundingClientRect();\n      es.isVisible = !!(b.width || b.height || b.top || b.left);\n      es.uncache = 1;\n    });\n  }\n  getElementState(element) {\n    return this.elementStates[this.targets.indexOf(_getEl(element))];\n  }\n  makeAbsolute() {\n    return _orderByDOMDepth(this.elementStates.slice(0), true, true).map(_makeAbsolute);\n  }\n}\nclass ElementState {\n  constructor(element, props, simple) {\n    this.element = element;\n    this.update(props, simple);\n  }\n  isDifferent(state) {\n    let b1 = this.bounds,\n      b2 = state.bounds;\n    return b1.top !== b2.top || b1.left !== b2.left || b1.width !== b2.width || b1.height !== b2.height || !this.matrix.equals(state.matrix) || this.opacity !== state.opacity || this.props && state.props && JSON.stringify(this.props) !== JSON.stringify(state.props);\n  }\n  update(props, simple) {\n    let self = this,\n      element = self.element,\n      getProp = gsap.getProperty(element),\n      cache = gsap.core.getCache(element),\n      bounds = element.getBoundingClientRect(),\n      bbox = element.getBBox && typeof element.getBBox === \"function\" && element.nodeName.toLowerCase() !== \"svg\" && element.getBBox(),\n      m = simple ? new Matrix2D(1, 0, 0, 1, bounds.left + _getDocScrollLeft(), bounds.top + _getDocScrollTop()) : getGlobalMatrix(element, false, false, true);\n    self.getProp = getProp;\n    self.element = element;\n    self.id = _getID(element);\n    self.matrix = m;\n    self.cache = cache;\n    self.bounds = bounds;\n    self.isVisible = !!(bounds.width || bounds.height || bounds.left || bounds.top);\n    self.display = getProp(\"display\");\n    self.position = getProp(\"position\");\n    self.parent = element.parentNode;\n    self.x = getProp(\"x\");\n    self.y = getProp(\"y\");\n    self.scaleX = cache.scaleX;\n    self.scaleY = cache.scaleY;\n    self.rotation = getProp(\"rotation\");\n    self.skewX = getProp(\"skewX\");\n    self.opacity = getProp(\"opacity\");\n    self.width = bbox ? bbox.width : _closestTenth(getProp(\"width\", \"px\"), 0.04); // round up to the closest 0.1 so that text doesn't wrap.\n    self.height = bbox ? bbox.height : _closestTenth(getProp(\"height\", \"px\"), 0.04);\n    props && _recordProps(self, _memoizedProps[props] || _memoizeProps(props));\n    self.ctm = element.getCTM && element.nodeName.toLowerCase() === \"svg\" && _getCTM(element).inverse();\n    self.simple = simple || _round(m.a) === 1 && !_round(m.b) && !_round(m.c) && _round(m.d) === 1; // allows us to speed through some other tasks if it's not scale/rotated\n    self.uncache = 0;\n  }\n}\nclass FlipAction {\n  constructor(vars, batch) {\n    this.vars = vars;\n    this.batch = batch;\n    this.states = [];\n    this.timeline = batch.timeline;\n  }\n  getStateById(id) {\n    let i = this.states.length;\n    while (i--) {\n      if (this.states[i].idLookup[id]) {\n        return this.states[i];\n      }\n    }\n  }\n  kill() {\n    this.batch.remove(this);\n  }\n}\nclass FlipBatch {\n  constructor(id) {\n    this.id = id;\n    this.actions = [];\n    this._kill = [];\n    this._final = [];\n    this._abs = [];\n    this._run = [];\n    this.data = {};\n    this.state = new FlipState();\n    this.timeline = gsap.timeline();\n  }\n  add(config) {\n    let result = this.actions.filter(action => action.vars === config);\n    if (result.length) {\n      return result[0];\n    }\n    result = new FlipAction(typeof config === \"function\" ? {\n      animate: config\n    } : config, this);\n    this.actions.push(result);\n    return result;\n  }\n  remove(action) {\n    let i = this.actions.indexOf(action);\n    i >= 0 && this.actions.splice(i, 1);\n    return this;\n  }\n  getState(merge) {\n    let prevBatch = _batch,\n      prevAction = _batchAction;\n    _batch = this;\n    this.state.clear();\n    this._kill.length = 0;\n    this.actions.forEach(action => {\n      if (action.vars.getState) {\n        action.states.length = 0;\n        _batchAction = action;\n        action.state = action.vars.getState(action);\n      }\n      merge && action.states.forEach(s => this.state.add(s));\n    });\n    _batchAction = prevAction;\n    _batch = prevBatch;\n    this.killConflicts();\n    return this;\n  }\n  animate() {\n    let prevBatch = _batch,\n      tl = this.timeline,\n      i = this.actions.length,\n      finalStates,\n      endTime;\n    _batch = this;\n    tl.clear();\n    this._abs.length = this._final.length = this._run.length = 0;\n    this.actions.forEach(a => {\n      a.vars.animate && a.vars.animate(a);\n      let onEnter = a.vars.onEnter,\n        onLeave = a.vars.onLeave,\n        targets = a.targets,\n        s,\n        result;\n      if (targets && targets.length && (onEnter || onLeave)) {\n        s = new FlipState();\n        a.states.forEach(state => s.add(state));\n        result = s.compare(Flip.getState(targets));\n        result.enter.length && onEnter && onEnter(result.enter);\n        result.leave.length && onLeave && onLeave(result.leave);\n      }\n    });\n    _makeCompsAbsolute(this._abs);\n    this._run.forEach(f => f());\n    endTime = tl.duration();\n    finalStates = this._final.slice(0);\n    tl.add(() => {\n      if (endTime <= tl.time()) {\n        // only call if moving forward in the timeline (in case it's nested in a timeline that gets reversed)\n        finalStates.forEach(f => f());\n        _forEachBatch(this, \"onComplete\");\n      }\n    });\n    _batch = prevBatch;\n    while (i--) {\n      this.actions[i].vars.once && this.actions[i].kill();\n    }\n    _forEachBatch(this, \"onStart\");\n    tl.restart();\n    return this;\n  }\n  loadState(done) {\n    done || (done = () => 0);\n    let queue = [];\n    this.actions.forEach(c => {\n      if (c.vars.loadState) {\n        let i,\n          f = targets => {\n            targets && (c.targets = targets);\n            i = queue.indexOf(f);\n            if (~i) {\n              queue.splice(i, 1);\n              queue.length || done();\n            }\n          };\n        queue.push(f);\n        c.vars.loadState(f);\n      }\n    });\n    queue.length || done();\n    return this;\n  }\n  setState() {\n    this.actions.forEach(c => c.targets = c.vars.setState && c.vars.setState(c));\n    return this;\n  }\n  killConflicts(soft) {\n    this.state.interrupt(soft);\n    this._kill.forEach(state => state.interrupt(soft));\n    return this;\n  }\n  run(skipGetState, merge) {\n    if (this !== _batch) {\n      skipGetState || this.getState(merge);\n      this.loadState(() => {\n        if (!this._killed) {\n          this.setState();\n          this.animate();\n        }\n      });\n    }\n    return this;\n  }\n  clear(stateOnly) {\n    this.state.clear();\n    stateOnly || (this.actions.length = 0);\n  }\n  getStateById(id) {\n    let i = this.actions.length,\n      s;\n    while (i--) {\n      s = this.actions[i].getStateById(id);\n      if (s) {\n        return s;\n      }\n    }\n    return this.state.idLookup[id] && this.state;\n  }\n  kill() {\n    this._killed = 1;\n    this.clear();\n    delete _batchLookup[this.id];\n  }\n}\nexport class Flip {\n  static getState(targets, vars) {\n    let state = _parseState(targets, vars);\n    _batchAction && _batchAction.states.push(state);\n    vars && vars.batch && Flip.batch(vars.batch).state.add(state);\n    return state;\n  }\n  static from(state, vars) {\n    vars = vars || {};\n    \"clearProps\" in vars || (vars.clearProps = true);\n    return _fromTo(state, _parseState(vars.targets || state.targets, {\n      props: vars.props || state.props,\n      simple: vars.simple,\n      kill: !!vars.kill\n    }), vars, -1);\n  }\n  static to(state, vars) {\n    return _fromTo(state, _parseState(vars.targets || state.targets, {\n      props: vars.props || state.props,\n      simple: vars.simple,\n      kill: !!vars.kill\n    }), vars, 1);\n  }\n  static fromTo(fromState, toState, vars) {\n    return _fromTo(fromState, toState, vars);\n  }\n  static fit(fromEl, toEl, vars) {\n    let v = vars ? _copy(vars, _fitReserved) : {},\n      {\n        absolute,\n        scale,\n        getVars,\n        props,\n        runBackwards,\n        onComplete,\n        simple\n      } = vars || v,\n      fitChild = vars && vars.fitChild && _getEl(vars.fitChild),\n      before = _parseElementState(toEl, props, simple, fromEl),\n      after = _parseElementState(fromEl, 0, simple, before),\n      inlineProps = props ? _memoizedRemoveProps[props] : _removeProps,\n      ctx = gsap.context();\n    props && _applyProps(v, before.props);\n    _recordInlineStyles(after, inlineProps);\n    if (runBackwards) {\n      \"immediateRender\" in v || (v.immediateRender = true);\n      v.onComplete = function () {\n        _applyInlineStyles(after);\n        onComplete && onComplete.apply(this, arguments);\n      };\n    }\n    absolute && _makeAbsolute(after, before);\n    v = _fit(after, before, scale || fitChild, props, fitChild, v.duration || getVars ? v : 0);\n    ctx && !getVars && ctx.add(() => () => _applyInlineStyles(after));\n    return getVars ? v : v.duration ? gsap.to(after.element, v) : null;\n  }\n  static makeAbsolute(targetsOrStates, vars) {\n    return (targetsOrStates instanceof FlipState ? targetsOrStates : new FlipState(targetsOrStates, vars)).makeAbsolute();\n  }\n  static batch(id) {\n    id || (id = \"default\");\n    return _batchLookup[id] || (_batchLookup[id] = new FlipBatch(id));\n  }\n  static killFlipsOf(targets, complete) {\n    (targets instanceof FlipState ? targets.targets : _toArray(targets)).forEach(t => t && _killFlip(t._flip, complete !== false ? 1 : 2));\n  }\n  static isFlipping(target) {\n    let f = Flip.getByTarget(target);\n    return !!f && f.isActive();\n  }\n  static getByTarget(target) {\n    return (_getEl(target) || _emptyObj)._flip;\n  }\n  static getElementState(target, props) {\n    return new ElementState(_getEl(target), props);\n  }\n  static convertCoordinates(fromElement, toElement, point) {\n    let m = getGlobalMatrix(toElement, true, true).multiply(getGlobalMatrix(fromElement));\n    return point ? m.apply(point) : m;\n  }\n  static register(core) {\n    _body = typeof document !== \"undefined\" && document.body;\n    if (_body) {\n      gsap = core;\n      _setDoc(_body);\n      _toArray = gsap.utils.toArray;\n      _getStyleSaver = gsap.core.getStyleSaver;\n      let snap = gsap.utils.snap(0.1);\n      _closestTenth = (value, add) => snap(parseFloat(value) + add);\n    }\n  }\n}\nFlip.version = \"3.12.5\";\n\n// function whenImagesLoad(el, func) {\n// \tlet pending = [],\n// \t\tonLoad = e => {\n// \t\t\tpending.splice(pending.indexOf(e.target), 1);\n// \t\t\te.target.removeEventListener(\"load\", onLoad);\n// \t\t\tpending.length || func();\n// \t\t};\n// \tgsap.utils.toArray(el.tagName.toLowerCase() === \"img\" ? el : el.querySelectorAll(\"img\")).forEach(img => img.complete || img.addEventListener(\"load\", onLoad) || pending.push(img));\n// \tpending.length || func();\n// }\n\ntypeof window !== \"undefined\" && window.gsap && window.gsap.registerPlugin(Flip);\nexport { Flip as default };","map":{"version":3,"names":["getGlobalMatrix","_getDocScrollTop","_getDocScrollLeft","Matrix2D","_setDoc","_getCTM","_id","_toArray","gsap","_batch","_batchAction","_body","_closestTenth","_getStyleSaver","_forEachBatch","batch","name","actions","forEach","a","vars","_batchLookup","_RAD2DEG","Math","PI","_DEG2RAD","_emptyObj","_dashedNameLookup","_memoizedRemoveProps","_listToArray","list","split","join","_callbacks","_removeProps","_getEl","target","console","warn","_round","value","round","_toggleClass","targets","className","action","el","classList","_reserved","zIndex","kill","simple","spin","clearProps","toggleClass","onComplete","onUpdate","onInterrupt","onStart","delay","repeat","repeatDelay","yoyo","scale","fade","absolute","props","onEnter","onLeave","custom","paused","nested","prune","absoluteOnLeave","_fitReserved","fitChild","getVars","_camelToDashed","p","replace","toLowerCase","_copy","obj","exclude","result","_memoizedProps","_memoizeProps","concat","_getInverseGlobalMatrix","cache","_gsap","core","getCache","gmCache","ticker","frame","gMatrix","_getDOMDepth","invert","level","parent","parentNode","inc","l","previousSibling","_orderByDOMDepth","comps","isElStates","comp","d","element","t","sort","c1","c2","_recordInlineStyles","elState","style","css","i","length","v","getPropertyValue","push","_applyInlineStyles","state","uncache","removeProperty","indexOf","translate","_setFinalStates","onlyTransforms","c","finalStates","_absoluteProps","_makeAbsolute","fallbackNode","ignoreBatch","width","height","getProp","displayIsNone","cs","_abs","b","sd","_final","isVisible","display","matrix","window","getComputedStyle","gridArea","transition","position","top","left","ElementState","bounds","getBoundingClientRect","_fit","x","y","_filterComps","filter","renderTransform","_makeCompsAbsolute","_findElStateInState","other","idLookup","_parseElementState","id","elementStates","elOrNode","FlipState","_recordProps","getProperty","trim","parseFloat","_applyProps","_getID","getAttribute","setAttribute","_elementsFromElementStates","elStates","map","_handleCallback","callback","tl","add","fromState","toState","applyProps","scaleX","scaleY","rotation","styles","dimensionState","e","f","deep","skewX","fromPoint","toPoint","parentMatrix","bbox","clone","multiply","ctm","atan2","sqrt","cos","getBBox","ceil","apply","revert","_parseState","targetsOrState","_getChangingElState","to1","to2","alt","getElementState","_bodyMetrics","_bodyProps","_bodyLocked","_lockBodyScroll","lock","s","w","clientWidth","outerWidth","h","clientHeight","outerHeight","overflowY","overflowX","_fromTo","relative","stagger","tweenVars","animation","timeline","data","remainingProps","entering","leaving","swapOutTargets","spinNum","spinFunc","interrupted","addFunc","endTime","fromNode","toNode","run","swap","_flip","isDifferent","splice","opacity","maxWidth","max","maxHeight","minWidth","min","minHeight","classTargets","remove","autoRound","modifiers","immediateRender","utils","distribute","dummyArray","slice","eventCallback","duration","call","_zTime","batchTl","forward","time","_run","anim","_killFlip","_interrupt","onInterruptParams","getChildren","force","progress","_createLookup","lookup","constructor","targetsAreElementStates","soft","_kill","update","interrupt","recordInlineStyles","clear","fit","elStatesInOrder","toElStates","property","es","index","es2","compare","l1","l2","unchanged","changed","enter","leave","a1","a2","place","s1","s2","placeIfDoesNotExist","s1Alt","s2Alt","timelines","foundInProgress","updateVisibility","makeAbsolute","b1","b2","equals","JSON","stringify","self","nodeName","m","getCTM","inverse","FlipAction","states","getStateById","FlipBatch","config","animate","getState","merge","prevBatch","prevAction","killConflicts","Flip","once","restart","loadState","done","queue","setState","skipGetState","_killed","stateOnly","from","to","fromTo","fromEl","toEl","runBackwards","before","after","inlineProps","ctx","context","arguments","targetsOrStates","killFlipsOf","complete","isFlipping","getByTarget","isActive","convertCoordinates","fromElement","toElement","point","register","document","body","toArray","getStyleSaver","snap","version","registerPlugin","default"],"sources":["C:/Users/baros/Downloads/GSAP-Crack-master/src/Flip.js"],"sourcesContent":["/*!\n * Flip 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nimport { getGlobalMatrix, _getDocScrollTop, _getDocScrollLeft, Matrix2D, _setDoc, _getCTM } from \"./utils/matrix.js\";\n\nlet _id = 1,\n\t_toArray, gsap, _batch, _batchAction, _body, _closestTenth, _getStyleSaver,\n\t_forEachBatch = (batch, name) => batch.actions.forEach(a => a.vars[name] && a.vars[name](a)),\n\t_batchLookup = {},\n\t_RAD2DEG = 180 / Math.PI,\n\t_DEG2RAD = Math.PI / 180,\n\t_emptyObj = {},\n\t_dashedNameLookup = {},\n\t_memoizedRemoveProps = {},\n\t_listToArray = list => typeof(list) === \"string\" ? list.split(\" \").join(\"\").split(\",\") : list, // removes extra spaces contaminating the names, returns an Array.\n\t_callbacks = _listToArray(\"onStart,onUpdate,onComplete,onReverseComplete,onInterrupt\"),\n\t_removeProps = _listToArray(\"transform,transformOrigin,width,height,position,top,left,opacity,zIndex,maxWidth,maxHeight,minWidth,minHeight\"),\n\t_getEl = target => _toArray(target)[0] || console.warn(\"Element not found:\", target),\n\t_round = value => Math.round(value * 10000) / 10000 || 0,\n\t_toggleClass = (targets, className, action) => targets.forEach(el => el.classList[action](className)),\n\t_reserved = {zIndex:1, kill:1, simple:1, spin:1, clearProps:1, targets:1, toggleClass:1, onComplete:1, onUpdate:1, onInterrupt:1, onStart:1, delay:1, repeat:1, repeatDelay:1, yoyo:1, scale:1, fade:1, absolute:1, props:1, onEnter:1, onLeave:1, custom:1, paused:1, nested:1, prune:1, absoluteOnLeave: 1},\n\t_fitReserved = {zIndex:1, simple:1, clearProps:1, scale:1, absolute:1, fitChild:1, getVars:1, props:1},\n\t_camelToDashed = p => p.replace(/([A-Z])/g, \"-$1\").toLowerCase(),\n\t_copy = (obj, exclude) => {\n\t\tlet result = {}, p;\n\t\tfor (p in obj) {\n\t\t\texclude[p] || (result[p] = obj[p]);\n\t\t}\n\t\treturn result;\n\t},\n\t_memoizedProps = {},\n\t_memoizeProps = props => {\n\t\tlet p = _memoizedProps[props] = _listToArray(props);\n\t\t_memoizedRemoveProps[props] = p.concat(_removeProps);\n\t\treturn p;\n\t},\n\t_getInverseGlobalMatrix = el => { // integrates caching for improved performance\n\t\tlet cache = el._gsap || gsap.core.getCache(el);\n\t\tif (cache.gmCache === gsap.ticker.frame) {\n\t\t\treturn cache.gMatrix;\n\t\t}\n\t\tcache.gmCache = gsap.ticker.frame;\n\t\treturn (cache.gMatrix = getGlobalMatrix(el, true, false, true));\n\t},\n\t_getDOMDepth = (el, invert, level = 0) => { // In invert is true, the sibling depth is increments of 1, and parent/nesting depth is increments of 1000. This lets us order elements in an Array to reflect document flow.\n\t\tlet parent = el.parentNode,\n\t\t\tinc = 1000 * (10 ** level) * (invert ? -1 : 1),\n\t\t\tl = invert ? -inc * 900 : 0;\n\t\twhile (el) {\n\t\t\tl += inc;\n\t\t\tel = el.previousSibling;\n\t\t}\n\t\treturn parent ? l + _getDOMDepth(parent, invert, level + 1) : l;\n\t},\n\t_orderByDOMDepth = (comps, invert, isElStates) => {\n\t\tcomps.forEach(comp => comp.d = _getDOMDepth(isElStates ? comp.element : comp.t, invert));\n\t\tcomps.sort((c1, c2) => c1.d - c2.d);\n\t\treturn comps;\n\t},\n\t_recordInlineStyles = (elState, props) => { // records the current inline CSS properties into an Array in alternating name/value pairs that's stored in a \"css\" property on the state object so that we can revert later.\n\t\tlet style = elState.element.style,\n\t\t\ta = elState.css = elState.css || [],\n\t\t\ti = props.length,\n\t\t\tp, v;\n\t\twhile (i--) {\n\t\t\tp = props[i];\n\t\t\tv = style[p] || style.getPropertyValue(p);\n\t\t\ta.push(v ? p : _dashedNameLookup[p] || (_dashedNameLookup[p] = _camelToDashed(p)), v);\n\t\t}\n\t\treturn style;\n\t},\n\t_applyInlineStyles = state => {\n\t\tlet css = state.css,\n\t\t\tstyle = state.element.style,\n\t\t\ti = 0;\n\t\tstate.cache.uncache = 1;\n\t\tfor (; i < css.length; i+=2) {\n\t\t\tcss[i+1] ? (style[css[i]] = css[i+1]) : style.removeProperty(css[i]);\n\t\t}\n\t\tif (!css[css.indexOf(\"transform\")+1] && style.translate) { // CSSPlugin adds scale, translate, and rotate inline CSS as \"none\" in order to keep CSS rules from contaminating transforms.\n\t\t\tstyle.removeProperty(\"translate\");\n\t\t\tstyle.removeProperty(\"scale\");\n\t\t\tstyle.removeProperty(\"rotate\");\n\t\t}\n\t},\n\t_setFinalStates = (comps, onlyTransforms) => {\n\t\tcomps.forEach(c => c.a.cache.uncache = 1);\n\t\tonlyTransforms || comps.finalStates.forEach(_applyInlineStyles);\n\t},\n\t_absoluteProps = \"paddingTop,paddingRight,paddingBottom,paddingLeft,gridArea,transition\".split(\",\"), // properties that we must record just\n\t_makeAbsolute = (elState, fallbackNode, ignoreBatch) => {\n\t\tlet { element, width, height, uncache, getProp } = elState,\n\t\t\tstyle = element.style,\n\t\t\ti = 4,\n\t\t\tresult, displayIsNone, cs;\n\t\t(typeof(fallbackNode) !== \"object\") && (fallbackNode = elState);\n\t\tif (_batch && ignoreBatch !== 1) {\n\t\t\t_batch._abs.push({t: element, b: elState, a: elState, sd: 0});\n\t\t\t_batch._final.push(() => (elState.cache.uncache = 1) && _applyInlineStyles(elState));\n\t\t\treturn element;\n\t\t}\n\t\tdisplayIsNone = getProp(\"display\") === \"none\";\n\n\t\tif (!elState.isVisible || displayIsNone) {\n\t\t\tdisplayIsNone && (_recordInlineStyles(elState, [\"display\"]).display = fallbackNode.display);\n\t\t\telState.matrix = fallbackNode.matrix;\n\t\t\telState.width = width = elState.width || fallbackNode.width;\n\t\t\telState.height = height = elState.height || fallbackNode.height;\n\t\t}\n\n\t\t_recordInlineStyles(elState, _absoluteProps);\n\t\tcs = window.getComputedStyle(element);\n\t\twhile (i--) {\n\t\t\tstyle[_absoluteProps[i]] = cs[_absoluteProps[i]]; // record paddings as px-based because if removed from grid, percentage-based ones could be altered.\n\t\t}\n\t\tstyle.gridArea = \"1 / 1 / 1 / 1\";\n\t\tstyle.transition = \"none\";\n\n\t\tstyle.position = \"absolute\";\n\t\tstyle.width = width + \"px\";\n\t\tstyle.height = height + \"px\";\n\t\tstyle.top || (style.top = \"0px\");\n\t\tstyle.left || (style.left = \"0px\");\n\t\tif (uncache) {\n\t\t\tresult = new ElementState(element);\n\t\t} else { // better performance\n\t\t\tresult = _copy(elState, _emptyObj);\n\t\t\tresult.position = \"absolute\";\n\t\t\tif (elState.simple) {\n\t\t\t\tlet bounds = element.getBoundingClientRect();\n\t\t\t\tresult.matrix = new Matrix2D(1, 0, 0, 1, bounds.left + _getDocScrollLeft(), bounds.top + _getDocScrollTop());\n\t\t\t} else {\n\t\t\t\tresult.matrix = getGlobalMatrix(element, false, false, true);\n\t\t\t}\n\t\t}\n\t\tresult = _fit(result, elState, true);\n\t\telState.x = _closestTenth(result.x, 0.01);\n\t\telState.y = _closestTenth(result.y, 0.01);\n\t\treturn element;\n\t},\n\t_filterComps = (comps, targets) => {\n\t\tif (targets !== true) {\n\t\t\ttargets = _toArray(targets);\n\t\t\tcomps = comps.filter(c => {\n\t\t\t\tif (targets.indexOf((c.sd < 0 ? c.b : c.a).element) !== -1) {\n\t\t\t\t    return true;\n\t\t\t\t} else {\n\t\t\t\t\tc.t._gsap.renderTransform(1); // we must force transforms to render on anything that isn't being made position: absolute, otherwise the absolute position happens and then when animation begins it applies transforms which can create a new stacking context, throwing off positioning!\n\t\t\t\t\tif (c.b.isVisible) {\n\t\t\t\t\t\tc.t.style.width = c.b.width + \"px\"; // otherwise things can collapse when contents are made position: absolute.\n\t\t\t\t\t\tc.t.style.height = c.b.height + \"px\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn comps;\n\t},\n\t_makeCompsAbsolute = comps => _orderByDOMDepth(comps, true).forEach(c => (c.a.isVisible || c.b.isVisible) && _makeAbsolute(c.sd < 0 ? c.b : c.a, c.b, 1)),\n\t_findElStateInState = (state, other) => (other && state.idLookup[_parseElementState(other).id]) || state.elementStates[0],\n\t_parseElementState = (elOrNode, props, simple, other) => elOrNode instanceof ElementState ? elOrNode : elOrNode instanceof FlipState ? _findElStateInState(elOrNode, other) : new ElementState(typeof(elOrNode) === \"string\" ? _getEl(elOrNode) || console.warn(elOrNode + \" not found\") : elOrNode, props, simple),\n\t_recordProps = (elState, props) => {\n\t\tlet getProp = gsap.getProperty(elState.element, null, \"native\"),\n\t\t\tobj = elState.props = {},\n\t\t\ti = props.length;\n\t\twhile (i--) {\n\t\t\tobj[props[i]] = (getProp(props[i]) + \"\").trim();\n\t\t}\n\t\tobj.zIndex && (obj.zIndex = parseFloat(obj.zIndex) || 0);\n\t\treturn elState;\n\t},\n\t_applyProps = (element, props) => {\n\t\tlet style = element.style || element, // could pass in a vars object.\n\t\t\tp;\n\t\tfor (p in props) {\n\t\t\tstyle[p] = props[p];\n\t\t}\n\t},\n\t_getID = el => {\n\t\tlet id = el.getAttribute(\"data-flip-id\");\n\t\tid || el.setAttribute(\"data-flip-id\", (id = \"auto-\" + _id++));\n\t\treturn id;\n\t},\n\t_elementsFromElementStates = elStates => elStates.map(elState => elState.element),\n\t_handleCallback = (callback, elStates, tl) => callback && elStates.length && tl.add(callback(_elementsFromElementStates(elStates), tl, new FlipState(elStates, 0, true)), 0),\n\n\t_fit = (fromState, toState, scale, applyProps, fitChild, vars) => {\n\t\tlet { element, cache, parent, x, y } = fromState,\n\t\t\t{ width, height, scaleX, scaleY, rotation, bounds } = toState,\n\t\t\tstyles = vars && _getStyleSaver && _getStyleSaver(element, \"transform\"), // requires at least 3.11.5\n\t\t\tdimensionState = fromState,\n\t\t\t{e, f} = toState.matrix,\n\t\t\tdeep = fromState.bounds.width !== bounds.width || fromState.bounds.height !== bounds.height || fromState.scaleX !== scaleX || fromState.scaleY !== scaleY || fromState.rotation !== rotation,\n\t\t\tsimple = !deep && fromState.simple && toState.simple && !fitChild,\n\t\t\tskewX, fromPoint, toPoint, getProp, parentMatrix, matrix, bbox;\n\t\tif (simple || !parent) {\n\t\t\tscaleX = scaleY = 1;\n\t\t\trotation = skewX = 0;\n\t\t} else {\n\t\t\tparentMatrix = _getInverseGlobalMatrix(parent);\n\t\t\tmatrix = parentMatrix.clone().multiply(toState.ctm ? toState.matrix.clone().multiply(toState.ctm) : toState.matrix); // root SVG elements have a ctm that we must factor out (for example, viewBox:\"0 0 94 94\" with a width of 200px would scale the internals by 2.127 but when we're matching the size of the root <svg> element itself, that scaling shouldn't factor in!)\n\t\t\trotation = _round(Math.atan2(matrix.b, matrix.a) * _RAD2DEG);\n\t\t\tskewX = _round(Math.atan2(matrix.c, matrix.d) * _RAD2DEG + rotation) % 360; // in very rare cases, minor rounding might end up with 360 which should be 0.\n\t\t\tscaleX = Math.sqrt(matrix.a ** 2 + matrix.b ** 2);\n\t\t\tscaleY = Math.sqrt(matrix.c ** 2 + matrix.d ** 2) * Math.cos(skewX * _DEG2RAD);\n\t\t\tif (fitChild) {\n\t\t\t\tfitChild = _toArray(fitChild)[0];\n\t\t\t\tgetProp = gsap.getProperty(fitChild);\n\t\t\t\tbbox = fitChild.getBBox && typeof(fitChild.getBBox) === \"function\" && fitChild.getBBox();\n\t\t\t\tdimensionState = {scaleX: getProp(\"scaleX\"), scaleY: getProp(\"scaleY\"), width: bbox ? bbox.width : Math.ceil(parseFloat(getProp(\"width\", \"px\"))), height: bbox ? bbox.height : parseFloat(getProp(\"height\", \"px\")) };\n\t\t\t}\n\t\t\tcache.rotation = rotation + \"deg\";\n\t\t\tcache.skewX = skewX + \"deg\";\n\t\t}\n\t\tif (scale) {\n\t\t\tscaleX *= width === dimensionState.width || !dimensionState.width ? 1 : width / dimensionState.width; // note if widths are both 0, we should make scaleX 1 - some elements have box-sizing that incorporates padding, etc. and we don't want it to collapse in that case.\n\t\t\tscaleY *= height === dimensionState.height || !dimensionState.height ? 1 : height / dimensionState.height;\n\t\t\tcache.scaleX = scaleX;\n\t\t\tcache.scaleY = scaleY;\n\t\t} else {\n\t\t\twidth = _closestTenth(width * scaleX / dimensionState.scaleX, 0);\n\t\t\theight = _closestTenth(height * scaleY / dimensionState.scaleY, 0);\n\t\t\telement.style.width = width + \"px\";\n\t\t\telement.style.height = height + \"px\";\n\t\t}\n\t\t// if (fromState.isFixed) { // commented out because it's now taken care of in getGlobalMatrix() with a flag at the end.\n\t\t// \te -= _getDocScrollLeft();\n\t\t// \tf -= _getDocScrollTop();\n\t\t// }\n\t\tapplyProps && _applyProps(element, toState.props);\n\t\tif (simple || !parent) {\n\t\t\tx += e - fromState.matrix.e;\n\t\t\ty += f - fromState.matrix.f;\n\t\t} else if (deep || parent !== toState.parent) {\n\t\t\tcache.renderTransform(1, cache);\n\t\t\tmatrix = getGlobalMatrix(fitChild || element, false, false, true);\n\t\t\tfromPoint = parentMatrix.apply({x: matrix.e, y: matrix.f});\n\t\t\ttoPoint = parentMatrix.apply({x: e, y: f});\n\t\t\tx += toPoint.x - fromPoint.x;\n\t\t\ty += toPoint.y - fromPoint.y;\n\t\t} else { // use a faster/cheaper algorithm if we're just moving x/y\n\t\t\tparentMatrix.e = parentMatrix.f = 0;\n\t\t\ttoPoint = parentMatrix.apply({x: e - fromState.matrix.e, y: f - fromState.matrix.f});\n\t\t\tx += toPoint.x;\n\t\t\ty += toPoint.y;\n\t\t}\n\t\tx = _closestTenth(x, 0.02);\n\t\ty = _closestTenth(y, 0.02);\n\t\tif (vars && !(vars instanceof ElementState)) { // revert\n\t\t\tstyles && styles.revert();\n\t\t} else { // or apply the transform immediately\n\t\t\tcache.x = x + \"px\";\n\t\t\tcache.y = y + \"px\";\n\t\t\tcache.renderTransform(1, cache);\n\t\t}\n\t\tif (vars) {\n\t\t\tvars.x = x;\n\t\t\tvars.y = y;\n\t\t\tvars.rotation = rotation;\n\t\t\tvars.skewX = skewX;\n\t\t\tif (scale) {\n\t\t\t\tvars.scaleX = scaleX;\n\t\t\t\tvars.scaleY = scaleY;\n\t\t\t} else {\n\t\t\t\tvars.width = width;\n\t\t\t\tvars.height = height;\n\t\t\t}\n\t\t}\n\t\treturn vars || cache;\n\t},\n\n\t_parseState = (targetsOrState, vars) => targetsOrState instanceof FlipState ? targetsOrState : new FlipState(targetsOrState, vars),\n\t_getChangingElState = (toState, fromState, id) => {\n\t\tlet to1 = toState.idLookup[id],\n\t\t\tto2 = toState.alt[id];\n\t\treturn to2.isVisible && (!(fromState.getElementState(to2.element) || to2).isVisible || !to1.isVisible) ? to2 : to1;\n\t},\n\t_bodyMetrics = [], _bodyProps = \"width,height,overflowX,overflowY\".split(\",\"), _bodyLocked,\n\t_lockBodyScroll = lock => { // if there's no scrollbar, we should lock that so that measurements don't get affected by temporary repositioning, like if something is centered in the window.\n\t\tif (lock !== _bodyLocked) {\n\t\t\tlet s = _body.style,\n\t\t\t\tw = _body.clientWidth === window.outerWidth,\n\t\t\t\th = _body.clientHeight === window.outerHeight,\n\t\t\t\ti = 4;\n\t\t\tif (lock && (w || h)) {\n\t\t\t\twhile (i--) {\n\t\t\t\t\t_bodyMetrics[i] = s[_bodyProps[i]];\n\t\t\t\t}\n\t\t\t\tif (w) {\n\t\t\t\t\ts.width = _body.clientWidth + \"px\";\n\t\t\t\t\ts.overflowY = \"hidden\";\n\t\t\t\t}\n\t\t\t\tif (h) {\n\t\t\t\t\ts.height = _body.clientHeight + \"px\";\n\t\t\t\t\ts.overflowX = \"hidden\";\n\t\t\t\t}\n\t\t\t\t_bodyLocked= lock;\n\t\t\t} else if (_bodyLocked) {\n\t\t\t\twhile (i--) {\n\t\t\t\t\t_bodyMetrics[i] ? (s[_bodyProps[i]] = _bodyMetrics[i]) : s.removeProperty(_camelToDashed(_bodyProps[i]));\n\t\t\t\t}\n\t\t\t\t_bodyLocked = lock;\n\t\t\t}\n\t\t}\n\t},\n\n\t_fromTo = (fromState, toState, vars, relative) => { // relative is -1 if \"from()\", and 1 if \"to()\"\n\t\t(fromState instanceof FlipState && toState instanceof FlipState) || console.warn(\"Not a valid state object.\");\n\t\tvars = vars || {};\n\t\tlet { clearProps, onEnter, onLeave, absolute, absoluteOnLeave, custom, delay, paused, repeat, repeatDelay, yoyo, toggleClass, nested, zIndex, scale, fade, stagger, spin, prune } = vars,\n\t\t\tprops = (\"props\" in vars ? vars : fromState).props,\n\t\t\ttweenVars = _copy(vars, _reserved),\n\t\t\tanimation = gsap.timeline({ delay, paused, repeat, repeatDelay, yoyo, data: \"isFlip\" }),\n\t\t\tremainingProps = tweenVars,\n\t\t\tentering = [],\n\t\t\tleaving = [],\n\t\t\tcomps = [],\n\t\t\tswapOutTargets = [],\n\t\t\tspinNum = spin === true ? 1 : spin || 0,\n\t\t\tspinFunc = typeof(spin) === \"function\" ? spin : () => spinNum,\n\t\t\tinterrupted = fromState.interrupted || toState.interrupted,\n\t\t\taddFunc = animation[relative !== 1 ? \"to\" : \"from\"],\n\t\t\tv, p, endTime, i, el, comp, state, targets, finalStates, fromNode, toNode, run, a, b;\n\t\t//relative || (toState = (new FlipState(toState.targets, {props: props})).fit(toState, scale));\n\t\tfor (p in toState.idLookup) {\n\t\t\ttoNode = !toState.alt[p] ? toState.idLookup[p] : _getChangingElState(toState, fromState, p);\n\t\t\tel = toNode.element;\n\t\t\tfromNode = fromState.idLookup[p];\n\t\t\tfromState.alt[p] && el === fromNode.element && (fromState.alt[p].isVisible || !toNode.isVisible) && (fromNode = fromState.alt[p]);\n\t\t\tif (fromNode) {\n\t\t\t\tcomp = {t: el, b: fromNode, a: toNode, sd: fromNode.element === el ? 0 : toNode.isVisible ? 1 : -1};\n\t\t\t\tcomps.push(comp);\n\t\t\t\tif (comp.sd) {\n\t\t\t\t\tif (comp.sd < 0) {\n\t\t\t\t\t\tcomp.b = toNode;\n\t\t\t\t\t\tcomp.a = fromNode;\n\t\t\t\t\t}\n\t\t\t\t\t// for swapping elements that got interrupted, we must re-record the inline styles to ensure they're not tainted. Remember, .batch() permits getState() not to force in-progress flips to their end state.\n\t\t\t\t\tinterrupted && _recordInlineStyles(comp.b, props ? _memoizedRemoveProps[props] : _removeProps);\n\t\t\t\t\tfade && comps.push(comp.swap = {t: fromNode.element, b: comp.b, a: comp.a, sd: -comp.sd, swap: comp});\n\t\t\t\t}\n\t\t\t\tel._flip = fromNode.element._flip = _batch ? _batch.timeline : animation;\n\t\t\t} else if (toNode.isVisible) {\n\t\t\t\tcomps.push({t: el, b: _copy(toNode, {isVisible:1}), a: toNode, sd: 0, entering: 1}); // to include it in the \"entering\" Array and do absolute positioning if necessary\n\t\t\t\tel._flip = _batch ? _batch.timeline : animation;\n\t\t\t}\n\t\t}\n\n\t\tprops && (_memoizedProps[props] || _memoizeProps(props)).forEach(p => tweenVars[p] = i => comps[i].a.props[p]);\n\t\tcomps.finalStates = finalStates = [];\n\n\t\trun = () => {\n\t\t\t_orderByDOMDepth(comps);\n\t\t\t_lockBodyScroll(true); // otherwise, measurements may get thrown off when things get fit.\n\t\t\t// TODO: cache the matrix, especially for parent because it'll probably get reused quite a bit, but lock it to a particular cycle(?).\n\t\t\tfor (i = 0; i < comps.length; i++) {\n\t\t\t\tcomp = comps[i];\n\t\t\t\ta = comp.a;\n\t\t\t\tb = comp.b;\n\t\t\t\tif (prune && !a.isDifferent(b) && !comp.entering) { // only flip if things changed! Don't omit it from comps initially because that'd prevent the element from being positioned absolutely (if necessary)\n\t\t\t\t\tcomps.splice(i--, 1);\n\t\t\t\t} else {\n\t\t\t\t\tel = comp.t;\n\t\t\t\t\tnested && !(comp.sd < 0) && i && (a.matrix = getGlobalMatrix(el, false, false, true)); // moving a parent affects the position of children\n\t\t\t\t\tif (b.isVisible && a.isVisible) {\n\t\t\t\t\t\tif (comp.sd < 0) { // swapping OUT (swap direction of -1 is out)\n\t\t\t\t\t\t\tstate = new ElementState(el, props, fromState.simple);\n\t\t\t\t\t\t\t_fit(state, a, scale, 0, 0, state);\n\t\t\t\t\t\t\tstate.matrix = getGlobalMatrix(el, false, false, true);\n\t\t\t\t\t\t\tstate.css = comp.b.css;\n\t\t\t\t\t\t\tcomp.a = a = state;\n\t\t\t\t\t\t\tfade && (el.style.opacity = interrupted ? b.opacity : a.opacity);\n\t\t\t\t\t\t\tstagger && swapOutTargets.push(el);\n\t\t\t\t\t\t} else if (comp.sd > 0 && fade) { // swapping IN (swap direction of 1 is in)\n\t\t\t\t\t\t\tel.style.opacity = interrupted ? a.opacity - b.opacity : \"0\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_fit(a, b, scale, props);\n\n\t\t\t\t\t} else if (b.isVisible !== a.isVisible) { // either entering or leaving (one side is invisible)\n\t\t\t\t\t\tif (!b.isVisible) { // entering\n\t\t\t\t\t\t\ta.isVisible && entering.push(a);\n\t\t\t\t\t\t\tcomps.splice(i--, 1);\n\t\t\t\t\t\t} else if (!a.isVisible) { // leaving\n\t\t\t\t\t\t\tb.css = a.css;\n\t\t\t\t\t\t\tleaving.push(b);\n\t\t\t\t\t\t\tcomps.splice(i--, 1);\n\t\t\t\t\t\t\tabsolute && nested && _fit(a, b, scale, props);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!scale) {\n\t\t\t\t\t\tel.style.maxWidth = Math.max(a.width, b.width) + \"px\";\n\t\t\t\t\t\tel.style.maxHeight = Math.max(a.height, b.height) + \"px\";\n\t\t\t\t\t\tel.style.minWidth = Math.min(a.width, b.width) + \"px\";\n\t\t\t\t\t\tel.style.minHeight = Math.min(a.height, b.height) + \"px\";\n\t\t\t\t\t}\n\t\t\t\t\tnested && toggleClass && el.classList.add(toggleClass);\n\t\t\t\t}\n\t\t\t\tfinalStates.push(a);\n\t\t\t}\n\t\t\tlet classTargets;\n\t\t\tif (toggleClass) {\n\t\t\t\tclassTargets = finalStates.map(s => s.element);\n\t\t\t\tnested && classTargets.forEach(e => e.classList.remove(toggleClass)); // there could be a delay, so don't leave the classes applied (we'll do it in a timeline callback)\n\t\t\t}\n\n\t\t\t_lockBodyScroll(false);\n\n\t\t\tif (scale) {\n\t\t\t\ttweenVars.scaleX = i => comps[i].a.scaleX;\n\t\t\t\ttweenVars.scaleY = i => comps[i].a.scaleY;\n\t\t\t} else {\n\t\t\t\ttweenVars.width = i => comps[i].a.width + \"px\";\n\t\t\t\ttweenVars.height = i => comps[i].a.height + \"px\";\n\t\t\t\ttweenVars.autoRound = vars.autoRound || false;\n\t\t\t}\n\t\t\ttweenVars.x = i => comps[i].a.x + \"px\";\n\t\t\ttweenVars.y = i => comps[i].a.y + \"px\";\n\t\t\ttweenVars.rotation = i => comps[i].a.rotation + (spin ? spinFunc(i, targets[i], targets) * 360 : 0);\n\t\t\ttweenVars.skewX = i => comps[i].a.skewX;\n\n\t\t\ttargets = comps.map(c => c.t);\n\n\t\t\tif (zIndex || zIndex === 0) {\n\t\t\t\ttweenVars.modifiers = {zIndex: () => zIndex};\n\t\t\t\ttweenVars.zIndex = zIndex;\n\t\t\t\ttweenVars.immediateRender = vars.immediateRender !== false;\n\t\t\t}\n\n\t\t\tfade && (tweenVars.opacity = i => comps[i].sd < 0 ? 0 : comps[i].sd > 0 ? comps[i].a.opacity : \"+=0\");\n\n\t\t\tif (swapOutTargets.length) {\n\t\t\t\tstagger = gsap.utils.distribute(stagger);\n\t\t\t\tlet dummyArray = targets.slice(swapOutTargets.length);\n\t\t\t\ttweenVars.stagger = (i, el) => stagger(~swapOutTargets.indexOf(el) ? targets.indexOf(comps[i].swap.t) : i, el, dummyArray);\n\t\t\t}\n\n\t\t\t// // for testing...\n\t\t\t// gsap.delayedCall(vars.data ? 50 : 1, function() {\n\t\t\t// \tanimation.eventCallback(\"onComplete\", () => _setFinalStates(comps, !clearProps));\n\t\t\t// \taddFunc.call(animation, targets, tweenVars, 0).play();\n\t\t\t// });\n\t\t\t// return;\n\n\t\t\t_callbacks.forEach(name => vars[name] && animation.eventCallback(name, vars[name], vars[name + \"Params\"])); // apply callbacks to the timeline, not tweens (because \"custom\" timing can make multiple tweens)\n\n\t\t\tif (custom && targets.length) { // bust out the custom properties as their own tweens so they can use different eases, durations, etc.\n\t\t\t\tremainingProps = _copy(tweenVars, _reserved);\n\t\t\t\tif (\"scale\" in custom) {\n\t\t\t\t\tcustom.scaleX = custom.scaleY = custom.scale;\n\t\t\t\t\tdelete custom.scale;\n\t\t\t\t}\n\t\t\t\tfor (p in custom) {\n\t\t\t\t\tv = _copy(custom[p], _fitReserved);\n\t\t\t\t\tv[p] = tweenVars[p];\n\t\t\t\t\t!(\"duration\" in v) && (\"duration\" in tweenVars) && (v.duration = tweenVars.duration);\n\t\t\t\t\tv.stagger = tweenVars.stagger;\n\t\t\t\t\taddFunc.call(animation, targets, v, 0);\n\t\t\t\t\tdelete remainingProps[p];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (targets.length || leaving.length || entering.length) {\n\t\t\t\ttoggleClass && animation.add(() => _toggleClass(classTargets, toggleClass, animation._zTime < 0 ? \"remove\" : \"add\"), 0) && !paused && _toggleClass(classTargets, toggleClass, \"add\");\n\t\t\t\ttargets.length && addFunc.call(animation, targets, remainingProps, 0);\n\t\t\t}\n\n\t\t\t_handleCallback(onEnter, entering, animation);\n\t\t\t_handleCallback(onLeave, leaving, animation);\n\n\t\t\tlet batchTl = _batch && _batch.timeline;\n\n\t\t\tif (batchTl) {\n\t\t\t\tbatchTl.add(animation, 0);\n\t\t\t\t_batch._final.push(() => _setFinalStates(comps, !clearProps));\n\t\t\t}\n\n\t\t\tendTime = animation.duration();\n\t\t\tanimation.call(() => {\n\t\t\t\tlet forward = animation.time() >= endTime;\n\t\t\t\tforward && !batchTl && _setFinalStates(comps, !clearProps);\n\t\t\t\ttoggleClass && _toggleClass(classTargets, toggleClass, forward ? \"remove\" : \"add\");\n\t\t\t});\n\t\t};\n\n\t\tabsoluteOnLeave && (absolute = comps.filter(comp => !comp.sd && !comp.a.isVisible && comp.b.isVisible).map(comp => comp.a.element));\n\t\tif (_batch) {\n\t\t\tabsolute && _batch._abs.push(..._filterComps(comps, absolute));\n\t\t\t_batch._run.push(run);\n\t\t} else {\n\t\t\tabsolute && _makeCompsAbsolute(_filterComps(comps, absolute)); // when making absolute, we must go in a very particular order so that document flow changes don't affect things. Don't make it visible if both the before and after states are invisible! There's no point, and it could make things appear visible during the flip that shouldn't be.\n\t\t\trun();\n\t\t}\n\n\t\tlet anim = _batch ? _batch.timeline : animation;\n\t\tanim.revert = () => _killFlip(anim, 1, 1); // a Flip timeline should behave very different when reverting - it should actually jump to the end so that styles get cleared out.\n\n\t\treturn anim;\n\t},\n\t_interrupt = tl => {\n\t\ttl.vars.onInterrupt && tl.vars.onInterrupt.apply(tl, tl.vars.onInterruptParams || []);\n\t\ttl.getChildren(true, false, true).forEach(_interrupt);\n\t},\n\t_killFlip = (tl, action, force) => { // action: 0 = nothing, 1 = complete, 2 = only kill (don't complete)\n\t\tif (tl && tl.progress() < 1 && (!tl.paused() || force)) {\n\t\t\tif (action) {\n\t\t\t\t_interrupt(tl);\n\t\t\t\taction < 2 && tl.progress(1); // we should also kill it in case it was added to a parent timeline.\n\t\t\t\ttl.kill();\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t},\n\t_createLookup = state => {\n\t\tlet lookup = state.idLookup = {},\n\t\t\talt = state.alt = {},\n\t\t\telStates = state.elementStates,\n\t\t\ti = elStates.length,\n\t\t\telState;\n\t\twhile (i--) {\n\t\t\telState = elStates[i];\n\t\t\tlookup[elState.id] ? (alt[elState.id] = elState) : (lookup[elState.id] = elState);\n\t\t}\n\t};\n\n\n\n\n\n\nclass FlipState {\n\n\tconstructor(targets, vars, targetsAreElementStates) {\n\t\tthis.props = vars && vars.props;\n\t\tthis.simple = !!(vars && vars.simple);\n\t\tif (targetsAreElementStates) {\n\t\t\tthis.targets = _elementsFromElementStates(targets);\n\t\t\tthis.elementStates = targets;\n\t\t\t_createLookup(this);\n\t\t} else {\n\t\t\tthis.targets = _toArray(targets);\n\t\t\tlet soft = vars && (vars.kill === false || (vars.batch && !vars.kill));\n\t\t\t_batch && !soft && _batch._kill.push(this);\n\t\t\tthis.update(soft || !!_batch); // when batching, don't force in-progress flips to their end; we need to do that AFTER all getStates() are called.\n\t\t}\n\t}\n\n\tupdate(soft) {\n\t\tthis.elementStates = this.targets.map(el => new ElementState(el, this.props, this.simple));\n\t\t_createLookup(this);\n\t\tthis.interrupt(soft);\n\t\tthis.recordInlineStyles();\n\t\treturn this;\n\t}\n\n\tclear() {\n\t\tthis.targets.length = this.elementStates.length = 0;\n\t\t_createLookup(this);\n\t\treturn this;\n\t}\n\n\tfit(state, scale, nested) {\n\t\tlet elStatesInOrder = _orderByDOMDepth(this.elementStates.slice(0), false, true),\n\t\t\ttoElStates = (state || this).idLookup,\n\t\t\ti = 0,\n\t\t\tfromNode, toNode;\n\t\tfor (; i < elStatesInOrder.length; i++) {\n\t\t\tfromNode = elStatesInOrder[i];\n\t\t\tnested && (fromNode.matrix = getGlobalMatrix(fromNode.element, false, false, true)); // moving a parent affects the position of children\n\t\t\ttoNode = toElStates[fromNode.id];\n\t\t\ttoNode && _fit(fromNode, toNode, scale, true, 0, fromNode);\n\t\t\tfromNode.matrix = getGlobalMatrix(fromNode.element, false, false, true);\n\t\t}\n\t\treturn this;\n\t}\n\n\tgetProperty(element, property) {\n\t\tlet es = this.getElementState(element) || _emptyObj;\n\t\treturn (property in es ? es : es.props || _emptyObj)[property];\n\t}\n\n\tadd(state) {\n\t\tlet i = state.targets.length,\n\t\t\tlookup = this.idLookup,\n\t\t\talt = this.alt,\n\t\t\tindex, es, es2;\n\t\twhile (i--) {\n\t\t\tes = state.elementStates[i];\n\t\t\tes2 = lookup[es.id];\n\t\t\tif (es2 && (es.element === es2.element || (alt[es.id] && alt[es.id].element === es.element))) { // if the flip id is already in this FlipState, replace it!\n\t\t\t\tindex = this.elementStates.indexOf(es.element === es2.element ? es2 : alt[es.id]);\n\t\t\t\tthis.targets.splice(index, 1, state.targets[i]);\n\t\t\t\tthis.elementStates.splice(index, 1, es);\n\t\t\t} else {\n\t\t\t\tthis.targets.push(state.targets[i]);\n\t\t\t\tthis.elementStates.push(es);\n\t\t\t}\n\t\t}\n\t\tstate.interrupted && (this.interrupted = true);\n\t\tstate.simple || (this.simple = false);\n\t\t_createLookup(this);\n\t\treturn this;\n\t}\n\n\tcompare(state) {\n\t\tlet l1 = state.idLookup,\n\t\t\tl2 = this.idLookup,\n\t\t\tunchanged = [],\n\t\t\tchanged = [],\n\t\t\tenter = [],\n\t\t\tleave = [],\n\t\t\ttargets = [],\n\t\t\ta1 = state.alt,\n\t\t\ta2 = this.alt,\n\t\t\tplace = (s1, s2, el) => (s1.isVisible !== s2.isVisible ? (s1.isVisible ? enter : leave) : s1.isVisible ? changed : unchanged).push(el) && targets.push(el),\n\t\t\tplaceIfDoesNotExist = (s1, s2, el) => targets.indexOf(el) < 0 && place(s1, s2, el),\n\t\t\ts1, s2, p, el, s1Alt, s2Alt, c1, c2;\n\t\tfor (p in l1) {\n\t\t\ts1Alt = a1[p];\n\t\t\ts2Alt = a2[p];\n\t\t\ts1 = !s1Alt ? l1[p] : _getChangingElState(state, this, p);\n\t\t\tel = s1.element;\n\t\t\ts2 = l2[p];\n\t\t\tif (s2Alt) {\n\t\t\t\tc2 = s2.isVisible || (!s2Alt.isVisible && el === s2.element) ? s2 : s2Alt;\n\t\t\t\tc1 = s1Alt && !s1.isVisible && !s1Alt.isVisible && c2.element === s1Alt.element ? s1Alt : s1;\n\t\t\t\t//c1.element !== c2.element && c1.element === s2.element && (c2 = s2);\n\t\t\t\tif (c1.isVisible && c2.isVisible && c1.element !== c2.element) { // swapping, so force into \"changed\" array\n\t\t\t\t\t(c1.isDifferent(c2) ? changed : unchanged).push(c1.element, c2.element);\n\t\t\t\t\ttargets.push(c1.element, c2.element);\n\t\t\t\t} else {\n\t\t\t\t\tplace(c1, c2, c1.element);\n\t\t\t\t}\n\t\t\t\ts1Alt && c1.element === s1Alt.element && (s1Alt = l1[p]);\n\t\t\t\tplaceIfDoesNotExist(c1.element !== s2.element && s1Alt ? s1Alt : c1, s2, s2.element);\n\t\t\t\tplaceIfDoesNotExist(s1Alt && s1Alt.element === s2Alt.element ? s1Alt : c1, s2Alt, s2Alt.element);\n\t\t\t\ts1Alt && placeIfDoesNotExist(s1Alt, s2Alt.element === s1Alt.element ? s2Alt : s2, s1Alt.element);\n\t\t\t} else {\n\t\t\t\t!s2 ? enter.push(el) : !s2.isDifferent(s1) ? unchanged.push(el) : place(s1, s2, el);\n\t\t\t\ts1Alt && placeIfDoesNotExist(s1Alt, s2, s1Alt.element);\n\t\t\t}\n\t\t}\n\t\tfor (p in l2) {\n\t\t\tif (!l1[p]) {\n\t\t\t\tleave.push(l2[p].element);\n\t\t\t\ta2[p] && leave.push(a2[p].element);\n\t\t\t}\n\t\t}\n\t\treturn {changed, unchanged, enter, leave};\n\t}\n\n\trecordInlineStyles() {\n\t\tlet props = _memoizedRemoveProps[this.props] || _removeProps,\n\t\t\ti = this.elementStates.length;\n\t\twhile (i--) {\n\t\t\t_recordInlineStyles(this.elementStates[i], props);\n\t\t}\n\t}\n\n\tinterrupt(soft) { // soft = DON'T force in-progress flip animations to completion (like when running a batch, we can't immediately kill flips when getting states because it could contaminate positioning and other .getState() calls that will run in the batch (we kill AFTER all the .getState() calls complete).\n\t\tlet timelines = [];\n\t\tthis.targets.forEach(t => {\n\t\t\tlet tl = t._flip,\n\t\t\t\tfoundInProgress = _killFlip(tl, soft ? 0 : 1);\n\t\t\tsoft && foundInProgress && timelines.indexOf(tl) < 0 && tl.add(() => this.updateVisibility());\n\t\t\tfoundInProgress && timelines.push(tl);\n\t\t});\n\t\t!soft && timelines.length && this.updateVisibility(); // if we found an in-progress Flip animation, we must record all the values in their current state at that point BUT we should update the isVisible value AFTER pushing that flip to completion so that elements that are entering or leaving will populate those Arrays properly.\n\t\tthis.interrupted || (this.interrupted = !!timelines.length);\n\t}\n\n\tupdateVisibility() {\n\t\tthis.elementStates.forEach(es => {\n\t\t\tlet b = es.element.getBoundingClientRect();\n\t\t\tes.isVisible = !!(b.width || b.height || b.top || b.left);\n\t\t\tes.uncache = 1;\n\t\t});\n\t}\n\n\tgetElementState(element) {\n\t\treturn this.elementStates[this.targets.indexOf(_getEl(element))];\n\t}\n\n\tmakeAbsolute() {\n\t\treturn _orderByDOMDepth(this.elementStates.slice(0), true, true).map(_makeAbsolute);\n\t}\n\n}\n\n\n\nclass ElementState {\n\n\tconstructor(element, props, simple) {\n\t\tthis.element = element;\n\t\tthis.update(props, simple);\n\t}\n\n\tisDifferent(state) {\n\t\tlet b1 = this.bounds,\n\t\t\tb2 = state.bounds;\n\t\treturn b1.top !== b2.top || b1.left !== b2.left || b1.width !== b2.width || b1.height !== b2.height || !this.matrix.equals(state.matrix) || this.opacity !== state.opacity || (this.props && state.props && JSON.stringify(this.props) !== JSON.stringify(state.props));\n\t}\n\n\tupdate(props, simple) {\n\t\tlet self = this,\n\t\t\telement = self.element,\n\t\t\tgetProp = gsap.getProperty(element),\n\t\t\tcache = gsap.core.getCache(element),\n\t\t\tbounds = element.getBoundingClientRect(),\n\t\t\tbbox = element.getBBox && typeof(element.getBBox) === \"function\" && element.nodeName.toLowerCase() !== \"svg\" && element.getBBox(),\n\t\t\tm = simple ? new Matrix2D(1, 0, 0, 1, bounds.left + _getDocScrollLeft(), bounds.top + _getDocScrollTop()) : getGlobalMatrix(element, false, false, true);\n\t\tself.getProp = getProp;\n\t\tself.element = element;\n\t\tself.id = _getID(element);\n\t\tself.matrix = m;\n\t\tself.cache = cache;\n\t\tself.bounds = bounds;\n\t\tself.isVisible = !!(bounds.width || bounds.height || bounds.left || bounds.top);\n\t\tself.display = getProp(\"display\");\n\t\tself.position = getProp(\"position\");\n\t\tself.parent = element.parentNode;\n\t\tself.x = getProp(\"x\");\n\t\tself.y = getProp(\"y\");\n\t\tself.scaleX = cache.scaleX;\n\t\tself.scaleY = cache.scaleY;\n\t\tself.rotation = getProp(\"rotation\");\n\t\tself.skewX = getProp(\"skewX\");\n\t\tself.opacity = getProp(\"opacity\");\n\t\tself.width =  bbox ? bbox.width : _closestTenth(getProp(\"width\", \"px\"), 0.04); // round up to the closest 0.1 so that text doesn't wrap.\n\t\tself.height = bbox ? bbox.height : _closestTenth(getProp(\"height\", \"px\"), 0.04);\n\t\tprops && _recordProps(self, _memoizedProps[props] || _memoizeProps(props));\n\t\tself.ctm = element.getCTM && element.nodeName.toLowerCase() === \"svg\" && _getCTM(element).inverse();\n\t\tself.simple = simple || (_round(m.a) === 1 && !_round(m.b) && !_round(m.c) && _round(m.d) === 1); // allows us to speed through some other tasks if it's not scale/rotated\n\t\tself.uncache = 0;\n\t}\n\n}\n\nclass FlipAction {\n\tconstructor(vars, batch) {\n\t\tthis.vars = vars;\n\t\tthis.batch = batch;\n\t\tthis.states = [];\n\t\tthis.timeline = batch.timeline;\n\t}\n\n\tgetStateById(id) {\n\t\tlet i = this.states.length;\n\t\twhile (i--) {\n\t\t\tif (this.states[i].idLookup[id]) {\n\t\t\t\treturn this.states[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tkill() {\n\t\tthis.batch.remove(this);\n\t}\n}\n\nclass FlipBatch {\n\tconstructor(id) {\n\t\tthis.id = id;\n\t\tthis.actions = [];\n\t\tthis._kill = [];\n\t\tthis._final = [];\n\t\tthis._abs = [];\n\t\tthis._run = [];\n\t\tthis.data = {};\n\t\tthis.state = new FlipState();\n\t\tthis.timeline = gsap.timeline();\n\t}\n\n\tadd(config) {\n\t\tlet result = this.actions.filter(action => action.vars === config);\n\t\tif (result.length) {\n\t\t\treturn result[0];\n\t\t}\n\t\tresult = new FlipAction(typeof(config) === \"function\" ? {animate: config} : config, this);\n\t\tthis.actions.push(result);\n\t\treturn result;\n\t}\n\n\tremove(action) {\n\t\tlet i = this.actions.indexOf(action);\n\t\ti >= 0 && this.actions.splice(i, 1);\n\t\treturn this;\n\t}\n\n\tgetState(merge) {\n\t\tlet prevBatch = _batch,\n\t\t\tprevAction = _batchAction;\n\t\t_batch = this;\n\t\tthis.state.clear();\n\t\tthis._kill.length = 0;\n\t\tthis.actions.forEach(action => {\n\t\t\tif (action.vars.getState) {\n\t\t\t\taction.states.length = 0;\n\t\t\t\t_batchAction = action;\n\t\t\t\taction.state = action.vars.getState(action);\n\t\t\t}\n\t\t\tmerge && action.states.forEach(s => this.state.add(s));\n\t\t});\n\t\t_batchAction = prevAction;\n\t\t_batch = prevBatch;\n\t\tthis.killConflicts();\n\t\treturn this;\n\t}\n\n\tanimate() {\n\t\tlet prevBatch = _batch,\n\t\t\ttl = this.timeline,\n\t\t\ti = this.actions.length,\n\t\t\tfinalStates, endTime;\n\t\t_batch = this;\n\t\ttl.clear();\n\t\tthis._abs.length = this._final.length = this._run.length = 0;\n\t\tthis.actions.forEach(a => {\n\t\t\ta.vars.animate && a.vars.animate(a);\n\t\t\tlet onEnter = a.vars.onEnter,\n\t\t\t\tonLeave = a.vars.onLeave,\n\t\t\t\ttargets = a.targets, s, result;\n\t\t\tif (targets && targets.length && (onEnter || onLeave)) {\n\t\t\t\ts = new FlipState();\n\t\t\t\ta.states.forEach(state => s.add(state));\n\t\t\t\tresult = s.compare(Flip.getState(targets));\n\t\t\t\tresult.enter.length && onEnter && onEnter(result.enter);\n\t\t\t\tresult.leave.length && onLeave && onLeave(result.leave);\n\t\t\t}\n\t\t});\n\t\t_makeCompsAbsolute(this._abs);\n\t\tthis._run.forEach(f => f());\n\t\tendTime = tl.duration();\n\t\tfinalStates = this._final.slice(0);\n\t\ttl.add(() => {\n\t\t\tif (endTime <= tl.time()) { // only call if moving forward in the timeline (in case it's nested in a timeline that gets reversed)\n\t\t\t\tfinalStates.forEach(f => f());\n\t\t\t\t_forEachBatch(this, \"onComplete\");\n\t\t\t}\n\t\t});\n\t\t_batch = prevBatch;\n\t\twhile (i--) {\n\t\t\tthis.actions[i].vars.once && this.actions[i].kill();\n\t\t}\n\t\t_forEachBatch(this, \"onStart\");\n\t\ttl.restart();\n\t\treturn this;\n\t}\n\n\tloadState(done) {\n\t\tdone || (done = () => 0);\n\t\tlet queue = [];\n\t\tthis.actions.forEach(c => {\n\t\t\tif (c.vars.loadState) {\n\t\t\t\tlet i, f = targets => {\n\t\t\t\t\ttargets && (c.targets = targets);\n\t\t\t\t\ti = queue.indexOf(f);\n\t\t\t\t\tif (~i) {\n\t\t\t\t\t\tqueue.splice(i, 1);\n\t\t\t\t\t\tqueue.length || done();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tqueue.push(f);\n\t\t\t\tc.vars.loadState(f);\n\t\t\t}\n\t\t});\n\t\tqueue.length || done();\n\t\treturn this;\n\t}\n\n\tsetState() {\n\t\tthis.actions.forEach(c => c.targets = c.vars.setState && c.vars.setState(c));\n\t\treturn this;\n\t}\n\n\tkillConflicts(soft) {\n\t\tthis.state.interrupt(soft);\n\t\tthis._kill.forEach(state => state.interrupt(soft));\n\t\treturn this;\n\t}\n\n\trun(skipGetState, merge) {\n\t\tif (this !== _batch) {\n\t\t\tskipGetState || this.getState(merge);\n\t\t\tthis.loadState(() => {\n\t\t\t\tif (!this._killed) {\n\t\t\t\t\tthis.setState();\n\t\t\t\t\tthis.animate();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\tclear(stateOnly) {\n\t\tthis.state.clear();\n\t\tstateOnly || (this.actions.length = 0);\n\t}\n\n\tgetStateById(id) {\n\t\tlet i = this.actions.length,\n\t\t\ts;\n\t\twhile (i--) {\n\t\t\ts = this.actions[i].getStateById(id);\n\t\t\tif (s) {\n\t\t\t\treturn s;\n\t\t\t}\n\t\t}\n\t\treturn this.state.idLookup[id] && this.state;\n\t}\n\n\tkill() {\n\t\tthis._killed = 1;\n\t\tthis.clear();\n\t\tdelete _batchLookup[this.id];\n\t}\n}\n\n\nexport class Flip {\n\n\tstatic getState(targets, vars) {\n\t\tlet state = _parseState(targets, vars);\n\t\t_batchAction && _batchAction.states.push(state);\n\t\tvars && vars.batch && Flip.batch(vars.batch).state.add(state);\n\t\treturn state;\n\t}\n\n\tstatic from(state, vars) {\n\t\tvars = vars || {};\n\t\t(\"clearProps\" in vars) || (vars.clearProps = true);\n\t\treturn _fromTo(state, _parseState(vars.targets || state.targets, {props: vars.props || state.props, simple: vars.simple, kill: !!vars.kill}), vars, -1);\n\t}\n\n\tstatic to(state, vars) {\n\t\treturn _fromTo(state, _parseState(vars.targets || state.targets, {props: vars.props || state.props, simple: vars.simple, kill: !!vars.kill}), vars, 1);\n\t}\n\n\tstatic fromTo(fromState, toState, vars) {\n\t\treturn _fromTo(fromState, toState, vars);\n\t}\n\n\tstatic fit(fromEl, toEl, vars) {\n\t\tlet v = vars ? _copy(vars, _fitReserved) : {},\n\t\t\t{absolute, scale, getVars, props, runBackwards, onComplete, simple} = vars || v,\n\t\t\tfitChild = vars && vars.fitChild && _getEl(vars.fitChild),\n\t\t\tbefore = _parseElementState(toEl, props, simple, fromEl),\n\t\t\tafter = _parseElementState(fromEl, 0, simple, before),\n\t\t\tinlineProps = props ? _memoizedRemoveProps[props] : _removeProps,\n\t\t\tctx = gsap.context();\n\t\tprops && _applyProps(v, before.props);\n\t\t_recordInlineStyles(after, inlineProps);\n\t\tif (runBackwards) {\n\t\t\t(\"immediateRender\" in v) || (v.immediateRender = true);\n\t\t\tv.onComplete = function() {\n\t\t\t\t_applyInlineStyles(after);\n\t\t\t\tonComplete && onComplete.apply(this, arguments);\n\t\t\t};\n\t\t}\n\t\tabsolute && _makeAbsolute(after, before);\n\t\tv = _fit(after, before, scale || fitChild, props, fitChild, v.duration || getVars ? v : 0);\n\t\tctx && !getVars && ctx.add(() => () => _applyInlineStyles(after));\n\t\treturn getVars ? v : v.duration ? gsap.to(after.element, v) : null;\n\t}\n\n\tstatic makeAbsolute(targetsOrStates, vars) {\n\t\treturn (targetsOrStates instanceof FlipState ? targetsOrStates : new FlipState(targetsOrStates, vars)).makeAbsolute();\n\t}\n\n\tstatic batch(id) {\n\t\tid || (id = \"default\");\n\t\treturn _batchLookup[id] || (_batchLookup[id] = new FlipBatch(id));\n\t}\n\n\tstatic killFlipsOf(targets, complete) {\n\t\t(targets instanceof FlipState ? targets.targets : _toArray(targets)).forEach(t => t && _killFlip(t._flip, complete !== false ? 1 : 2));\n\t}\n\n\tstatic isFlipping(target) {\n\t\tlet f = Flip.getByTarget(target);\n\t\treturn !!f && f.isActive();\n\t}\n\n\tstatic getByTarget(target) {\n\t\treturn (_getEl(target) || _emptyObj)._flip;\n\t}\n\n\tstatic getElementState(target, props) {\n\t\treturn new ElementState(_getEl(target), props);\n\t}\n\n\tstatic convertCoordinates(fromElement, toElement, point) {\n\t\tlet m = getGlobalMatrix(toElement, true, true).multiply(getGlobalMatrix(fromElement));\n\t\treturn point ? m.apply(point) : m;\n\t}\n\n\n\tstatic register(core) {\n\t\t_body = typeof(document) !== \"undefined\" && document.body;\n\t\tif (_body) {\n\t\t\tgsap = core;\n\t\t\t_setDoc(_body);\n\t\t\t_toArray = gsap.utils.toArray;\n\t\t\t_getStyleSaver = gsap.core.getStyleSaver;\n\t\t\tlet snap = gsap.utils.snap(0.1);\n\t\t\t_closestTenth = (value, add) => snap(parseFloat(value) + add);\n\t\t}\n\t}\n}\n\nFlip.version = \"3.12.5\";\n\n// function whenImagesLoad(el, func) {\n// \tlet pending = [],\n// \t\tonLoad = e => {\n// \t\t\tpending.splice(pending.indexOf(e.target), 1);\n// \t\t\te.target.removeEventListener(\"load\", onLoad);\n// \t\t\tpending.length || func();\n// \t\t};\n// \tgsap.utils.toArray(el.tagName.toLowerCase() === \"img\" ? el : el.querySelectorAll(\"img\")).forEach(img => img.complete || img.addEventListener(\"load\", onLoad) || pending.push(img));\n// \tpending.length || func();\n// }\n\ntypeof(window) !== \"undefined\" && window.gsap && window.gsap.registerPlugin(Flip);\n\nexport { Flip as default };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}