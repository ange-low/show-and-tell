{"ast":null,"code":"/*!\n * MotionPathPlugin 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nimport { getRawPath, cacheRawPathMeasurements, getPositionOnPath, pointsToSegment, flatPointsToSegment, sliceRawPath, stringToRawPath, rawPathToString, transformRawPath, convertToPath } from \"./utils/paths.js\";\nimport { getGlobalMatrix } from \"./utils/matrix.js\";\nlet _xProps = \"x,translateX,left,marginLeft,xPercent\".split(\",\"),\n  _yProps = \"y,translateY,top,marginTop,yPercent\".split(\",\"),\n  _DEG2RAD = Math.PI / 180,\n  gsap,\n  PropTween,\n  _getUnit,\n  _toArray,\n  _getStyleSaver,\n  _reverting,\n  _getGSAP = () => gsap || typeof window !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap,\n  _populateSegmentFromArray = (segment, values, property, mode) => {\n    //mode: 0 = x but don't fill y yet, 1 = y, 2 = x and fill y with 0.\n    let l = values.length,\n      si = mode === 2 ? 0 : mode,\n      i = 0,\n      v;\n    for (; i < l; i++) {\n      segment[si] = v = parseFloat(values[i][property]);\n      mode === 2 && (segment[si + 1] = 0);\n      si += 2;\n    }\n    return segment;\n  },\n  _getPropNum = (target, prop, unit) => parseFloat(target._gsap.get(target, prop, unit || \"px\")) || 0,\n  _relativize = segment => {\n    let x = segment[0],\n      y = segment[1],\n      i;\n    for (i = 2; i < segment.length; i += 2) {\n      x = segment[i] += x;\n      y = segment[i + 1] += y;\n    }\n  },\n  // feed in an array of quadratic bezier points like [{x: 0, y: 0}, ...] and it'll convert it to cubic bezier\n  // _quadToCubic = points => {\n  // \tlet cubic = [],\n  // \t\tl = points.length - 1,\n  // \t\ti = 1,\n  // \t\ta, b, c;\n  // \tfor (; i < l; i+=2) {\n  // \t\ta = points[i-1];\n  // \t\tb = points[i];\n  // \t\tc = points[i+1];\n  // \t\tcubic.push(a, {x: (2 * b.x + a.x) / 3, y: (2 * b.y + a.y) / 3}, {x: (2 * b.x + c.x) / 3, y: (2 * b.y + c.y) / 3});\n  // \t}\n  // \tcubic.push(points[l]);\n  // \treturn cubic;\n  // },\n  _segmentToRawPath = (plugin, segment, target, x, y, slicer, vars, unitX, unitY) => {\n    if (vars.type === \"cubic\") {\n      segment = [segment];\n    } else {\n      vars.fromCurrent !== false && segment.unshift(_getPropNum(target, x, unitX), y ? _getPropNum(target, y, unitY) : 0);\n      vars.relative && _relativize(segment);\n      let pointFunc = y ? pointsToSegment : flatPointsToSegment;\n      segment = [pointFunc(segment, vars.curviness)];\n    }\n    segment = slicer(_align(segment, target, vars));\n    _addDimensionalPropTween(plugin, target, x, segment, \"x\", unitX);\n    y && _addDimensionalPropTween(plugin, target, y, segment, \"y\", unitY);\n    return cacheRawPathMeasurements(segment, vars.resolution || (vars.curviness === 0 ? 20 : 12)); //when curviness is 0, it creates control points right on top of the anchors which makes it more sensitive to resolution, thus we change the default accordingly.\n  },\n  _emptyFunc = v => v,\n  _numExp = /[-+\\.]*\\d+\\.?(?:e-|e\\+)?\\d*/g,\n  _originToPoint = (element, origin, parentMatrix) => {\n    // origin is an array of normalized values (0-1) in relation to the width/height, so [0.5, 0.5] would be the center. It can also be \"auto\" in which case it will be the top left unless it's a <path>, when it will start at the beginning of the path itself.\n    let m = getGlobalMatrix(element),\n      x = 0,\n      y = 0,\n      svg;\n    if ((element.tagName + \"\").toLowerCase() === \"svg\") {\n      svg = element.viewBox.baseVal;\n      svg.width || (svg = {\n        width: +element.getAttribute(\"width\"),\n        height: +element.getAttribute(\"height\")\n      });\n    } else {\n      svg = origin && element.getBBox && element.getBBox();\n    }\n    if (origin && origin !== \"auto\") {\n      x = origin.push ? origin[0] * (svg ? svg.width : element.offsetWidth || 0) : origin.x;\n      y = origin.push ? origin[1] * (svg ? svg.height : element.offsetHeight || 0) : origin.y;\n    }\n    return parentMatrix.apply(x || y ? m.apply({\n      x: x,\n      y: y\n    }) : {\n      x: m.e,\n      y: m.f\n    });\n  },\n  _getAlignMatrix = (fromElement, toElement, fromOrigin, toOrigin) => {\n    let parentMatrix = getGlobalMatrix(fromElement.parentNode, true, true),\n      m = parentMatrix.clone().multiply(getGlobalMatrix(toElement)),\n      fromPoint = _originToPoint(fromElement, fromOrigin, parentMatrix),\n      {\n        x,\n        y\n      } = _originToPoint(toElement, toOrigin, parentMatrix),\n      p;\n    m.e = m.f = 0;\n    if (toOrigin === \"auto\" && toElement.getTotalLength && toElement.tagName.toLowerCase() === \"path\") {\n      p = toElement.getAttribute(\"d\").match(_numExp) || [];\n      p = m.apply({\n        x: +p[0],\n        y: +p[1]\n      });\n      x += p.x;\n      y += p.y;\n    }\n    //if (p || (toElement.getBBox && fromElement.getBBox && toElement.ownerSVGElement === fromElement.ownerSVGElement)) {\n    if (p) {\n      p = m.apply(toElement.getBBox());\n      x -= p.x;\n      y -= p.y;\n    }\n    m.e = x - fromPoint.x;\n    m.f = y - fromPoint.y;\n    return m;\n  },\n  _align = (rawPath, target, {\n    align,\n    matrix,\n    offsetX,\n    offsetY,\n    alignOrigin\n  }) => {\n    let x = rawPath[0][0],\n      y = rawPath[0][1],\n      curX = _getPropNum(target, \"x\"),\n      curY = _getPropNum(target, \"y\"),\n      alignTarget,\n      m,\n      p;\n    if (!rawPath || !rawPath.length) {\n      return getRawPath(\"M0,0L0,0\");\n    }\n    if (align) {\n      if (align === \"self\" || (alignTarget = _toArray(align)[0] || target) === target) {\n        transformRawPath(rawPath, 1, 0, 0, 1, curX - x, curY - y);\n      } else {\n        if (alignOrigin && alignOrigin[2] !== false) {\n          gsap.set(target, {\n            transformOrigin: alignOrigin[0] * 100 + \"% \" + alignOrigin[1] * 100 + \"%\"\n          });\n        } else {\n          alignOrigin = [_getPropNum(target, \"xPercent\") / -100, _getPropNum(target, \"yPercent\") / -100];\n        }\n        m = _getAlignMatrix(target, alignTarget, alignOrigin, \"auto\");\n        p = m.apply({\n          x: x,\n          y: y\n        });\n        transformRawPath(rawPath, m.a, m.b, m.c, m.d, curX + m.e - (p.x - m.e), curY + m.f - (p.y - m.f));\n      }\n    }\n    if (matrix) {\n      transformRawPath(rawPath, matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);\n    } else if (offsetX || offsetY) {\n      transformRawPath(rawPath, 1, 0, 0, 1, offsetX || 0, offsetY || 0);\n    }\n    return rawPath;\n  },\n  _addDimensionalPropTween = (plugin, target, property, rawPath, pathProperty, forceUnit) => {\n    let cache = target._gsap,\n      harness = cache.harness,\n      alias = harness && harness.aliases && harness.aliases[property],\n      prop = alias && alias.indexOf(\",\") < 0 ? alias : property,\n      pt = plugin._pt = new PropTween(plugin._pt, target, prop, 0, 0, _emptyFunc, 0, cache.set(target, prop, plugin));\n    pt.u = _getUnit(cache.get(target, prop, forceUnit)) || 0;\n    pt.path = rawPath;\n    pt.pp = pathProperty;\n    plugin._props.push(prop);\n  },\n  _sliceModifier = (start, end) => rawPath => start || end !== 1 ? sliceRawPath(rawPath, start, end) : rawPath;\nexport const MotionPathPlugin = {\n  version: \"3.12.5\",\n  name: \"motionPath\",\n  register(core, Plugin, propTween) {\n    gsap = core;\n    _getUnit = gsap.utils.getUnit;\n    _toArray = gsap.utils.toArray;\n    _getStyleSaver = gsap.core.getStyleSaver;\n    _reverting = gsap.core.reverting || function () {};\n    PropTween = propTween;\n  },\n  init(target, vars, tween) {\n    if (!gsap) {\n      console.warn(\"Please gsap.registerPlugin(MotionPathPlugin)\");\n      return false;\n    }\n    if (!(typeof vars === \"object\" && !vars.style) || !vars.path) {\n      vars = {\n        path: vars\n      };\n    }\n    let rawPaths = [],\n      {\n        path,\n        autoRotate,\n        unitX,\n        unitY,\n        x,\n        y\n      } = vars,\n      firstObj = path[0],\n      slicer = _sliceModifier(vars.start, \"end\" in vars ? vars.end : 1),\n      rawPath,\n      p;\n    this.rawPaths = rawPaths;\n    this.target = target;\n    this.tween = tween;\n    this.styles = _getStyleSaver && _getStyleSaver(target, \"transform\");\n    if (this.rotate = autoRotate || autoRotate === 0) {\n      //get the rotational data FIRST so that the setTransform() method is called in the correct order in the render() loop - rotation gets set last.\n      this.rOffset = parseFloat(autoRotate) || 0;\n      this.radians = !!vars.useRadians;\n      this.rProp = vars.rotation || \"rotation\"; // rotation property\n      this.rSet = target._gsap.set(target, this.rProp, this); // rotation setter\n      this.ru = _getUnit(target._gsap.get(target, this.rProp)) || 0; // rotation units\n    }\n    if (Array.isArray(path) && !(\"closed\" in path) && typeof firstObj !== \"number\") {\n      for (p in firstObj) {\n        if (!x && ~_xProps.indexOf(p)) {\n          x = p;\n        } else if (!y && ~_yProps.indexOf(p)) {\n          y = p;\n        }\n      }\n      if (x && y) {\n        //correlated values\n        rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray(_populateSegmentFromArray([], path, x, 0), path, y, 1), target, x, y, slicer, vars, unitX || _getUnit(path[0][x]), unitY || _getUnit(path[0][y])));\n      } else {\n        x = y = 0;\n      }\n      for (p in firstObj) {\n        p !== x && p !== y && rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray([], path, p, 2), target, p, 0, slicer, vars, _getUnit(path[0][p])));\n      }\n    } else {\n      rawPath = slicer(_align(getRawPath(vars.path), target, vars));\n      cacheRawPathMeasurements(rawPath, vars.resolution);\n      rawPaths.push(rawPath);\n      _addDimensionalPropTween(this, target, vars.x || \"x\", rawPath, \"x\", vars.unitX || \"px\");\n      _addDimensionalPropTween(this, target, vars.y || \"y\", rawPath, \"y\", vars.unitY || \"px\");\n    }\n  },\n  render(ratio, data) {\n    let rawPaths = data.rawPaths,\n      i = rawPaths.length,\n      pt = data._pt;\n    if (data.tween._time || !_reverting()) {\n      if (ratio > 1) {\n        ratio = 1;\n      } else if (ratio < 0) {\n        ratio = 0;\n      }\n      while (i--) {\n        getPositionOnPath(rawPaths[i], ratio, !i && data.rotate, rawPaths[i]);\n      }\n      while (pt) {\n        pt.set(pt.t, pt.p, pt.path[pt.pp] + pt.u, pt.d, ratio);\n        pt = pt._next;\n      }\n      data.rotate && data.rSet(data.target, data.rProp, rawPaths[0].angle * (data.radians ? _DEG2RAD : 1) + data.rOffset + data.ru, data, ratio);\n    } else {\n      data.styles.revert();\n    }\n  },\n  getLength(path) {\n    return cacheRawPathMeasurements(getRawPath(path)).totalLength;\n  },\n  sliceRawPath,\n  getRawPath,\n  pointsToSegment,\n  stringToRawPath,\n  rawPathToString,\n  transformRawPath,\n  getGlobalMatrix,\n  getPositionOnPath,\n  cacheRawPathMeasurements,\n  convertToPath: (targets, swap) => _toArray(targets).map(target => convertToPath(target, swap !== false)),\n  convertCoordinates(fromElement, toElement, point) {\n    let m = getGlobalMatrix(toElement, true, true).multiply(getGlobalMatrix(fromElement));\n    return point ? m.apply(point) : m;\n  },\n  getAlignMatrix: _getAlignMatrix,\n  getRelativePosition(fromElement, toElement, fromOrigin, toOrigin) {\n    let m = _getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin);\n    return {\n      x: m.e,\n      y: m.f\n    };\n  },\n  arrayToRawPath(value, vars) {\n    vars = vars || {};\n    let segment = _populateSegmentFromArray(_populateSegmentFromArray([], value, vars.x || \"x\", 0), value, vars.y || \"y\", 1);\n    vars.relative && _relativize(segment);\n    return [vars.type === \"cubic\" ? segment : pointsToSegment(segment, vars.curviness)];\n  }\n};\n_getGSAP() && gsap.registerPlugin(MotionPathPlugin);\nexport { MotionPathPlugin as default };","map":{"version":3,"names":["getRawPath","cacheRawPathMeasurements","getPositionOnPath","pointsToSegment","flatPointsToSegment","sliceRawPath","stringToRawPath","rawPathToString","transformRawPath","convertToPath","getGlobalMatrix","_xProps","split","_yProps","_DEG2RAD","Math","PI","gsap","PropTween","_getUnit","_toArray","_getStyleSaver","_reverting","_getGSAP","window","registerPlugin","_populateSegmentFromArray","segment","values","property","mode","l","length","si","i","v","parseFloat","_getPropNum","target","prop","unit","_gsap","get","_relativize","x","y","_segmentToRawPath","plugin","slicer","vars","unitX","unitY","type","fromCurrent","unshift","relative","pointFunc","curviness","_align","_addDimensionalPropTween","resolution","_emptyFunc","_numExp","_originToPoint","element","origin","parentMatrix","m","svg","tagName","toLowerCase","viewBox","baseVal","width","getAttribute","height","getBBox","push","offsetWidth","offsetHeight","apply","e","f","_getAlignMatrix","fromElement","toElement","fromOrigin","toOrigin","parentNode","clone","multiply","fromPoint","p","getTotalLength","match","rawPath","align","matrix","offsetX","offsetY","alignOrigin","curX","curY","alignTarget","set","transformOrigin","a","b","c","d","pathProperty","forceUnit","cache","harness","alias","aliases","indexOf","pt","_pt","u","path","pp","_props","_sliceModifier","start","end","MotionPathPlugin","version","name","register","core","Plugin","propTween","utils","getUnit","toArray","getStyleSaver","reverting","init","tween","console","warn","style","rawPaths","autoRotate","firstObj","styles","rotate","rOffset","radians","useRadians","rProp","rotation","rSet","ru","Array","isArray","render","ratio","data","_time","t","_next","angle","revert","getLength","totalLength","targets","swap","map","convertCoordinates","point","getAlignMatrix","getRelativePosition","arrayToRawPath","value","default"],"sources":["C:/Users/baros/Downloads/GSAP-Crack-master/src/MotionPathPlugin.js"],"sourcesContent":["/*!\n * MotionPathPlugin 3.12.5\n * https://gsap.com\n *\n * @license Copyright 2008-2024, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n/* eslint-disable */\n\nimport { getRawPath, cacheRawPathMeasurements, getPositionOnPath, pointsToSegment, flatPointsToSegment, sliceRawPath, stringToRawPath, rawPathToString, transformRawPath, convertToPath } from \"./utils/paths.js\";\nimport { getGlobalMatrix } from \"./utils/matrix.js\";\n\nlet _xProps = \"x,translateX,left,marginLeft,xPercent\".split(\",\"),\n\t_yProps = \"y,translateY,top,marginTop,yPercent\".split(\",\"),\n\t_DEG2RAD = Math.PI / 180,\n\tgsap, PropTween, _getUnit, _toArray, _getStyleSaver, _reverting,\n\t_getGSAP = () => gsap || (typeof(window) !== \"undefined\" && (gsap = window.gsap) && gsap.registerPlugin && gsap),\n\t_populateSegmentFromArray = (segment, values, property, mode) => { //mode: 0 = x but don't fill y yet, 1 = y, 2 = x and fill y with 0.\n\t\tlet l = values.length,\n\t\t\tsi = mode === 2 ? 0 : mode,\n\t\t\ti = 0,\n\t\t\tv;\n\t\tfor (; i < l; i++) {\n\t\t\tsegment[si] = v = parseFloat(values[i][property]);\n\t\t\tmode === 2 && (segment[si+1] = 0);\n\t\t\tsi += 2;\n\t\t}\n\t\treturn segment;\n\t},\n\t_getPropNum = (target, prop, unit) => parseFloat(target._gsap.get(target, prop, unit || \"px\")) || 0,\n\t_relativize = segment => {\n\t\tlet x = segment[0],\n\t\t\ty = segment[1],\n\t\t\ti;\n\t\tfor (i = 2; i < segment.length; i+=2) {\n\t\t\tx = (segment[i] += x);\n\t\t\ty = (segment[i+1] += y);\n\t\t}\n\t},\n\t// feed in an array of quadratic bezier points like [{x: 0, y: 0}, ...] and it'll convert it to cubic bezier\n\t// _quadToCubic = points => {\n\t// \tlet cubic = [],\n\t// \t\tl = points.length - 1,\n\t// \t\ti = 1,\n\t// \t\ta, b, c;\n\t// \tfor (; i < l; i+=2) {\n\t// \t\ta = points[i-1];\n\t// \t\tb = points[i];\n\t// \t\tc = points[i+1];\n\t// \t\tcubic.push(a, {x: (2 * b.x + a.x) / 3, y: (2 * b.y + a.y) / 3}, {x: (2 * b.x + c.x) / 3, y: (2 * b.y + c.y) / 3});\n\t// \t}\n\t// \tcubic.push(points[l]);\n\t// \treturn cubic;\n\t// },\n\t_segmentToRawPath = (plugin, segment, target, x, y, slicer, vars, unitX, unitY) => {\n\t\tif (vars.type === \"cubic\") {\n\t\t\tsegment = [segment];\n\t\t} else {\n\t\t\tvars.fromCurrent !== false && segment.unshift(_getPropNum(target, x, unitX), y ? _getPropNum(target, y, unitY) : 0);\n\t\t\tvars.relative && _relativize(segment);\n\t\t\tlet pointFunc = y ? pointsToSegment : flatPointsToSegment;\n\t\t\tsegment = [pointFunc(segment, vars.curviness)];\n\t\t}\n\t\tsegment = slicer(_align(segment, target, vars));\n\t\t_addDimensionalPropTween(plugin, target, x, segment, \"x\", unitX);\n\t\ty && _addDimensionalPropTween(plugin, target, y, segment, \"y\", unitY);\n\t\treturn cacheRawPathMeasurements(segment, vars.resolution || (vars.curviness === 0 ? 20 : 12)); //when curviness is 0, it creates control points right on top of the anchors which makes it more sensitive to resolution, thus we change the default accordingly.\n\t},\n\t_emptyFunc = v => v,\n\t_numExp = /[-+\\.]*\\d+\\.?(?:e-|e\\+)?\\d*/g,\n\t_originToPoint = (element, origin, parentMatrix) => { // origin is an array of normalized values (0-1) in relation to the width/height, so [0.5, 0.5] would be the center. It can also be \"auto\" in which case it will be the top left unless it's a <path>, when it will start at the beginning of the path itself.\n\t\tlet m = getGlobalMatrix(element),\n\t\t\tx = 0,\n\t\t\ty = 0,\n\t\t\tsvg;\n\t\tif ((element.tagName + \"\").toLowerCase() === \"svg\") {\n\t\t\tsvg = element.viewBox.baseVal;\n\t\t\tsvg.width || (svg = {width: +element.getAttribute(\"width\"), height: +element.getAttribute(\"height\")});\n\t\t} else {\n\t\t\tsvg = origin && element.getBBox && element.getBBox();\n\t\t}\n\t\tif (origin && origin !== \"auto\") {\n\t\t\tx = origin.push ? origin[0] * (svg ? svg.width : element.offsetWidth || 0) : origin.x;\n\t\t\ty = origin.push ? origin[1] * (svg ? svg.height : element.offsetHeight || 0) : origin.y;\n\t\t}\n\t\treturn parentMatrix.apply( x || y ? m.apply({x: x, y: y}) : {x: m.e, y: m.f} );\n\t},\n\t_getAlignMatrix = (fromElement, toElement, fromOrigin, toOrigin) => {\n\t\tlet parentMatrix = getGlobalMatrix(fromElement.parentNode, true, true),\n\t\t\tm = parentMatrix.clone().multiply(getGlobalMatrix(toElement)),\n\t\t\tfromPoint = _originToPoint(fromElement, fromOrigin, parentMatrix),\n\t\t\t{x, y} = _originToPoint(toElement, toOrigin, parentMatrix),\n\t\t\tp;\n\t\tm.e = m.f = 0;\n\t\tif (toOrigin === \"auto\" && toElement.getTotalLength && toElement.tagName.toLowerCase() === \"path\") {\n\t\t\tp = toElement.getAttribute(\"d\").match(_numExp) || [];\n\t\t\tp = m.apply({x:+p[0], y:+p[1]});\n\t\t\tx += p.x;\n\t\t\ty += p.y;\n\t\t}\n\t\t//if (p || (toElement.getBBox && fromElement.getBBox && toElement.ownerSVGElement === fromElement.ownerSVGElement)) {\n\t\tif (p) {\n\t\t\tp = m.apply(toElement.getBBox());\n\t\t\tx -= p.x;\n\t\t\ty -= p.y;\n\t\t}\n\t\tm.e = x - fromPoint.x;\n\t\tm.f = y - fromPoint.y;\n\t\treturn m;\n\t},\n\t_align = (rawPath, target, {align, matrix, offsetX, offsetY, alignOrigin}) => {\n\t\tlet x = rawPath[0][0],\n\t\t\ty = rawPath[0][1],\n\t\t\tcurX = _getPropNum(target, \"x\"),\n\t\t\tcurY = _getPropNum(target, \"y\"),\n\t\t\talignTarget, m, p;\n\t\tif (!rawPath || !rawPath.length) {\n\t\t\treturn getRawPath(\"M0,0L0,0\");\n\t\t}\n\t\tif (align) {\n\t\t\tif (align === \"self\" || ((alignTarget = _toArray(align)[0] || target) === target)) {\n\t\t\t\ttransformRawPath(rawPath, 1, 0, 0, 1, curX - x, curY - y);\n\t\t\t} else {\n\t\t\t\tif (alignOrigin && alignOrigin[2] !== false) {\n\t\t\t\t\tgsap.set(target, {transformOrigin:(alignOrigin[0] * 100) + \"% \" + (alignOrigin[1] * 100) + \"%\"});\n\t\t\t\t} else {\n\t\t\t\t\talignOrigin = [_getPropNum(target, \"xPercent\") / -100, _getPropNum(target, \"yPercent\") / -100];\n\t\t\t\t}\n\t\t\t\tm = _getAlignMatrix(target, alignTarget, alignOrigin, \"auto\");\n\t\t\t\tp = m.apply({x: x, y: y});\n\t\t\t\ttransformRawPath(rawPath, m.a, m.b, m.c, m.d, curX + m.e - (p.x - m.e), curY + m.f - (p.y - m.f));\n\t\t\t}\n\t\t}\n\t\tif (matrix) {\n\t\t\ttransformRawPath(rawPath, matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);\n\t\t} else if (offsetX || offsetY) {\n\t\t\ttransformRawPath(rawPath, 1, 0, 0, 1, offsetX || 0, offsetY || 0);\n\t\t}\n\t\treturn rawPath;\n\t},\n\t_addDimensionalPropTween = (plugin, target, property, rawPath, pathProperty, forceUnit) => {\n\t\tlet cache = target._gsap,\n\t\t\tharness = cache.harness,\n\t\t\talias = (harness && harness.aliases && harness.aliases[property]),\n\t\t\tprop = alias && alias.indexOf(\",\") < 0 ? alias : property,\n\t\t\tpt = plugin._pt = new PropTween(plugin._pt, target, prop, 0, 0, _emptyFunc, 0, cache.set(target, prop, plugin));\n\t\tpt.u = _getUnit(cache.get(target, prop, forceUnit)) || 0;\n\t\tpt.path = rawPath;\n\t\tpt.pp = pathProperty;\n\t\tplugin._props.push(prop);\n\t},\n\t_sliceModifier = (start, end) => rawPath => (start || end !== 1) ? sliceRawPath(rawPath, start, end) : rawPath;\n\n\nexport const MotionPathPlugin = {\n\tversion: \"3.12.5\",\n\tname: \"motionPath\",\n\tregister(core, Plugin, propTween) {\n\t\tgsap = core;\n\t\t_getUnit = gsap.utils.getUnit;\n\t\t_toArray = gsap.utils.toArray;\n\t\t_getStyleSaver = gsap.core.getStyleSaver;\n\t\t_reverting = gsap.core.reverting || function() {};\n\t\tPropTween = propTween;\n\t},\n\tinit(target, vars, tween) {\n\t\tif (!gsap) {\n\t\t\tconsole.warn(\"Please gsap.registerPlugin(MotionPathPlugin)\");\n\t\t\treturn false;\n\t\t}\n\t\tif (!(typeof(vars) === \"object\" && !vars.style) || !vars.path) {\n\t\t\tvars = {path:vars};\n\t\t}\n\t\tlet rawPaths = [],\n\t\t\t{path, autoRotate, unitX, unitY, x, y} = vars,\n\t\t\tfirstObj = path[0],\n\t\t\tslicer = _sliceModifier(vars.start, (\"end\" in vars) ? vars.end : 1),\n\t\t\trawPath, p;\n\t\tthis.rawPaths = rawPaths;\n\t\tthis.target = target;\n\t\tthis.tween = tween;\n\t\tthis.styles = _getStyleSaver && _getStyleSaver(target, \"transform\");\n\t\tif ((this.rotate = (autoRotate || autoRotate === 0))) { //get the rotational data FIRST so that the setTransform() method is called in the correct order in the render() loop - rotation gets set last.\n\t\t\tthis.rOffset = parseFloat(autoRotate) || 0;\n\t\t\tthis.radians = !!vars.useRadians;\n\t\t\tthis.rProp = vars.rotation || \"rotation\";                       // rotation property\n\t\t\tthis.rSet = target._gsap.set(target, this.rProp, this);         // rotation setter\n\t\t\tthis.ru = _getUnit(target._gsap.get(target, this.rProp)) || 0;  // rotation units\n\t\t}\n\t\tif (Array.isArray(path) && !(\"closed\" in path) && typeof(firstObj) !== \"number\") {\n\t\t\tfor (p in firstObj) {\n\t\t\t\tif (!x && ~_xProps.indexOf(p)) {\n\t\t\t\t\tx = p;\n\t\t\t\t} else if (!y && ~_yProps.indexOf(p)) {\n\t\t\t\t\ty = p;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (x && y) { //correlated values\n\t\t\t\trawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray(_populateSegmentFromArray([], path, x, 0), path, y, 1), target, x, y, slicer, vars, unitX || _getUnit(path[0][x]), unitY || _getUnit(path[0][y])));\n\t\t\t} else {\n\t\t\t\tx = y = 0;\n\t\t\t}\n\t\t\tfor (p in firstObj) {\n\t\t\t\tp !== x && p !== y && rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray([], path, p, 2), target, p, 0, slicer, vars, _getUnit(path[0][p])));\n\t\t\t}\n\t\t} else {\n\t\t\trawPath = slicer(_align(getRawPath(vars.path), target, vars));\n\t\t\tcacheRawPathMeasurements(rawPath, vars.resolution);\n\t\t\trawPaths.push(rawPath);\n\t\t\t_addDimensionalPropTween(this, target, vars.x || \"x\", rawPath, \"x\", vars.unitX || \"px\");\n\t\t\t_addDimensionalPropTween(this, target, vars.y || \"y\", rawPath, \"y\", vars.unitY || \"px\");\n\t\t}\n\t},\n\trender(ratio, data) {\n\t\tlet rawPaths = data.rawPaths,\n\t\t\ti = rawPaths.length,\n\t\t\tpt = data._pt;\n\t\tif (data.tween._time || !_reverting()) {\n\t\t\tif (ratio > 1) {\n\t\t\t\tratio = 1;\n\t\t\t} else if (ratio < 0) {\n\t\t\t\tratio = 0;\n\t\t\t}\n\t\t\twhile (i--) {\n\t\t\t\tgetPositionOnPath(rawPaths[i], ratio, !i && data.rotate, rawPaths[i]);\n\t\t\t}\n\t\t\twhile (pt) {\n\t\t\t\tpt.set(pt.t, pt.p, pt.path[pt.pp] + pt.u, pt.d, ratio);\n\t\t\t\tpt = pt._next;\n\t\t\t}\n\t\t\tdata.rotate && data.rSet(data.target, data.rProp, rawPaths[0].angle * (data.radians ? _DEG2RAD : 1) + data.rOffset + data.ru, data, ratio);\n\t\t} else {\n\t\t\tdata.styles.revert();\n\t\t}\n\t},\n\tgetLength(path) {\n\t\treturn cacheRawPathMeasurements(getRawPath(path)).totalLength;\n\t},\n\tsliceRawPath,\n\tgetRawPath,\n\tpointsToSegment,\n\tstringToRawPath,\n\trawPathToString,\n\ttransformRawPath,\n\tgetGlobalMatrix,\n\tgetPositionOnPath,\n\tcacheRawPathMeasurements,\n\tconvertToPath: (targets, swap) => _toArray(targets).map(target => convertToPath(target, swap !== false)),\n\tconvertCoordinates(fromElement, toElement, point) {\n\t\tlet m = getGlobalMatrix(toElement, true, true).multiply(getGlobalMatrix(fromElement));\n\t\treturn point ? m.apply(point) : m;\n\t},\n\tgetAlignMatrix: _getAlignMatrix,\n\tgetRelativePosition(fromElement, toElement, fromOrigin, toOrigin) {\n\t\tlet m =_getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin);\n\t\treturn {x: m.e, y: m.f};\n\t},\n\tarrayToRawPath(value, vars) {\n\t\tvars = vars || {};\n\t\tlet segment = _populateSegmentFromArray(_populateSegmentFromArray([], value, vars.x || \"x\", 0), value, vars.y || \"y\", 1);\n\t\tvars.relative && _relativize(segment);\n\t\treturn [(vars.type === \"cubic\") ? segment : pointsToSegment(segment, vars.curviness)];\n\t}\n};\n\n_getGSAP() && gsap.registerPlugin(MotionPathPlugin);\n\nexport { MotionPathPlugin as default };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}